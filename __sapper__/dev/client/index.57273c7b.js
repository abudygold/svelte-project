import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, u as create_slot, w as assign, x as compute_rest_props, v as validate_slots, y as forwardEventsBuilder, z as get_current_component, A as exclude_internal_props, B as useActions, e as element, c as claim_element, b as children, g as detach_dev, C as set_attributes, j as add_location, k as insert_dev, D as action_destroyer, E as update_slot, F as get_spread_update, G as is_function, H as transition_in, I as transition_out, J as run_all, K as binding_callbacks, L as svg_element, M as set_svg_attributes, N as classMap, O as getContext, P as create_component, Q as empty, R as claim_component, T as mount_component, U as get_spread_object, V as group_outros, W as destroy_component, X as check_outros, Y as writable, Z as Ripple, _ as setContext, $ as dispatch, a0 as A, a1 as Button, h as attr_dev, o as space, p as claim_space, a2 as Span, l as append_dev, n as noop, a3 as __extends, a4 as __assign, a5 as __awaiter, a6 as MDCFoundation, a7 as __generator, a8 as globals, a9 as compute_slots, aa as validate_store, ab as component_subscribe, ac as onMount, ad as onDestroy, ae as ponyfill, af as set_store_value, ag as listen_dev, t as text, f as claim_text, m as set_data_dev, ah as bind, ai as IconButton, aj as add_flush_callback, a as validate_each_argument, ak as validate_each_keys, al as update_keyed_each, am as outro_and_destroy_block, q as query_selector_all } from './client.456fd1fc.js';
import { p as prefixFilter, e as exclude } from './prefixFilter.5cb4521a.js';

/* node_modules\@smui\common\I.svelte generated by Svelte v3.38.3 */
const file$9 = "node_modules\\@smui\\common\\I.svelte";

function create_fragment$c(ctx) {
	let i;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let i_levels = [/*$$restProps*/ ctx[3]];
	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", {});
			var i_nodes = children(i);
			if (default_slot) default_slot.l(i_nodes);
			i_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(i, i_data);
			add_location(i, file$9, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);

			if (default_slot) {
				default_slot.m(i, null);
			}

			/*i_binding*/ ctx[7](i);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, i, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, i))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], !current ? -1 : dirty, null, null);
				}
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (default_slot) default_slot.d(detaching);
			/*i_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("I", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function i_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		i_binding
	];
}

class I extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$c, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "I",
			options,
			id: create_fragment$c.name
		});
	}

	get use() {
		throw new Error("<I>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\Svg.svelte generated by Svelte v3.38.3 */
const file$8 = "node_modules\\@smui\\common\\Svg.svelte";

function create_fragment$b(ctx) {
	let svg;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let svg_levels = [/*$$restProps*/ ctx[3]];
	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", {}, 1);
			var svg_nodes = children(svg);
			if (default_slot) default_slot.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$8, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			/*svg_binding*/ ctx[7](svg);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, svg, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, svg))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], !current ? -1 : dirty, null, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (default_slot) default_slot.d(detaching);
			/*svg_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Svg", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function svg_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		svg_binding
	];
}

class Svg extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$b, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Svg",
			options,
			id: create_fragment$b.name
		});
	}

	get use() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\CommonIcon.svelte generated by Svelte v3.38.3 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__icon': context === 'button',     'mdc-fab__icon': context === 'fab',     'mdc-icon-button__icon': context === 'icon-button',     'mdc-icon-button__icon--on': context === 'icon-button' && on,     'mdc-tab__icon': context === 'tab',     'mdc-banner__icon': context === 'banner',     'mdc-segmented-button__icon': context === 'segmented-button',   })}   aria-hidden="true"   {...component === Svg ? { focusable: 'false', tabindex: '-1' } : {}}   {...$$restProps}>
function create_default_slot$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? -1 : dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__icon': context === 'button',     'mdc-fab__icon': context === 'fab',     'mdc-icon-button__icon': context === 'icon-button',     'mdc-icon-button__icon--on': context === 'icon-button' && on,     'mdc-tab__icon': context === 'tab',     'mdc-banner__icon': context === 'banner',     'mdc-segmented-button__icon': context === 'segmented-button',   })}   aria-hidden=\\\"true\\\"   {...component === Svg ? { focusable: 'false', tabindex: '-1' } : {}}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button__icon": /*context*/ ctx[6] === "button",
				"mdc-fab__icon": /*context*/ ctx[6] === "fab",
				"mdc-icon-button__icon": /*context*/ ctx[6] === "icon-button",
				"mdc-icon-button__icon--on": /*context*/ ctx[6] === "icon-button" && /*on*/ ctx[2],
				"mdc-tab__icon": /*context*/ ctx[6] === "tab",
				"mdc-banner__icon": /*context*/ ctx[6] === "banner",
				"mdc-segmented-button__icon": /*context*/ ctx[6] === "segmented-button"
			})
		},
		{ "aria-hidden": "true" },
		/*component*/ ctx[3] === Svg
		? { focusable: "false", tabindex: "-1" }
		: {},
		/*$$restProps*/ ctx[7]
	];

	var switch_value = /*component*/ ctx[3];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$4] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[10](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, context, on, component, Svg, $$restProps*/ 239)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 33 && {
						use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, context, on*/ 70 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button__icon": /*context*/ ctx[6] === "button",
							"mdc-fab__icon": /*context*/ ctx[6] === "fab",
							"mdc-icon-button__icon": /*context*/ ctx[6] === "icon-button",
							"mdc-icon-button__icon--on": /*context*/ ctx[6] === "icon-button" && /*on*/ ctx[2],
							"mdc-tab__icon": /*context*/ ctx[6] === "tab",
							"mdc-banner__icon": /*context*/ ctx[6] === "banner",
							"mdc-segmented-button__icon": /*context*/ ctx[6] === "segmented-button"
						})
					},
					switch_instance_spread_levels[2],
					dirty & /*component, Svg*/ 8 && get_spread_object(/*component*/ ctx[3] === Svg
					? { focusable: "false", tabindex: "-1" }
					: {}),
					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
				])
			: {};

			if (dirty & /*$$scope*/ 2048) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[3])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[10](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[10](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","on","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonIcon", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { on = false } = $$props;
	let element;
	let { component = I } = $$props;
	const context = getContext("SMUI:icon:context");

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("on" in $$new_props) $$invalidate(2, on = $$new_props.on);
		if ("component" in $$new_props) $$invalidate(3, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		I,
		Svg,
		forwardEvents,
		use,
		className,
		on,
		element,
		component,
		context,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("on" in $$props) $$invalidate(2, on = $$new_props.on);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(3, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		on,
		component,
		element,
		forwardEvents,
		context,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class CommonIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$a, safe_not_equal, {
			use: 0,
			class: 1,
			on: 2,
			component: 3,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonIcon",
			options,
			id: create_fragment$a.name
		});
	}

	get use() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get on() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set on(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const users = writable([
    {
        "id": 1,
        "name": "Leanne Graham",
        "username": "Bret",
        "email": "Sincere@april.biz",
        "website": "hildegard.org",
    },
    {
        "id": 2,
        "name": "Ervin Howell",
        "username": "Antonette",
        "email": "Shanna@melissa.tv",
        "website": "anastasia.net",
    },
    {
        "id": 3,
        "name": "Clementine Bauch",
        "username": "Samantha",
        "email": "Nathan@yesenia.net",
        "website": "ramiro.info",
    },
    /* {
        "id": 4,
        "name": "Patricia Lebsack",
        "username": "Karianne",
        "email": "Julianne.OConner@kory.org",
        "address": {
            "street": "Hoeger Mall",
            "suite": "Apt. 692",
            "city": "South Elvis",
            "zipcode": "53919-4257",
            "geo": {
                "lat": "29.4572",
                "lng": "-164.2990"
            }
        },
        "phone": "493-170-9623 x156",
        "website": "kale.biz",
        "company": {
            "name": "Robel-Corkery",
            "catchPhrase": "Multi-tiered zero tolerance productivity",
            "bs": "transition cutting-edge web services"
        }
    },
    {
        "id": 5,
        "name": "Chelsey Dietrich",
        "username": "Kamren",
        "email": "Lucio_Hettinger@annie.ca",
        "address": {
            "street": "Skiles Walks",
            "suite": "Suite 351",
            "city": "Roscoeview",
            "zipcode": "33263",
            "geo": {
                "lat": "-31.8129",
                "lng": "62.5342"
            }
        },
        "phone": "(254)954-1289",
        "website": "demarco.info",
        "company": {
            "name": "Keebler LLC",
            "catchPhrase": "User-centric fault-tolerant solution",
            "bs": "revolutionize end-to-end systems"
        }
    },
    {
        "id": 6,
        "name": "Mrs. Dennis Schulist",
        "username": "Leopoldo_Corkery",
        "email": "Karley_Dach@jasper.info",
        "address": {
            "street": "Norberto Crossing",
            "suite": "Apt. 950",
            "city": "South Christy",
            "zipcode": "23505-1337",
            "geo": {
                "lat": "-71.4197",
                "lng": "71.7478"
            }
        },
        "phone": "1-477-935-8478 x6430",
        "website": "ola.org",
        "company": {
            "name": "Considine-Lockman",
            "catchPhrase": "Synchronised bottom-line interface",
            "bs": "e-enable innovative applications"
        }
    },
    {
        "id": 7,
        "name": "Kurtis Weissnat",
        "username": "Elwyn.Skiles",
        "email": "Telly.Hoeger@billy.biz",
        "address": {
            "street": "Rex Trail",
            "suite": "Suite 280",
            "city": "Howemouth",
            "zipcode": "58804-1099",
            "geo": {
                "lat": "24.8918",
                "lng": "21.8984"
            }
        },
        "phone": "210.067.6132",
        "website": "elvis.io",
        "company": {
            "name": "Johns Group",
            "catchPhrase": "Configurable multimedia task-force",
            "bs": "generate enterprise e-tailers"
        }
    },
    {
        "id": 8,
        "name": "Nicholas Runolfsdottir V",
        "username": "Maxime_Nienow",
        "email": "Sherwood@rosamond.me",
        "address": {
            "street": "Ellsworth Summit",
            "suite": "Suite 729",
            "city": "Aliyaview",
            "zipcode": "45169",
            "geo": {
                "lat": "-14.3990",
                "lng": "-120.7677"
            }
        },
        "phone": "586.493.6943 x140",
        "website": "jacynthe.com",
        "company": {
            "name": "Abernathy Group",
            "catchPhrase": "Implemented secondary concept",
            "bs": "e-enable extensible e-tailers"
        }
    },
    {
        "id": 9,
        "name": "Glenna Reichert",
        "username": "Delphine",
        "email": "Chaim_McDermott@dana.io",
        "address": {
            "street": "Dayna Park",
            "suite": "Suite 449",
            "city": "Bartholomebury",
            "zipcode": "76495-3109",
            "geo": {
                "lat": "24.6463",
                "lng": "-168.8889"
            }
        },
        "phone": "(775)976-6794 x41206",
        "website": "conrad.com",
        "company": {
            "name": "Yost and Sons",
            "catchPhrase": "Switchable contextually-based project",
            "bs": "aggregate real-time technologies"
        }
    },
    {
        "id": 10,
        "name": "Clementina DuBuque",
        "username": "Moriah.Stanton",
        "email": "Rey.Padberg@karina.biz",
        "address": {
            "street": "Kattie Turnpike",
            "suite": "Suite 198",
            "city": "Lebsackbury",
            "zipcode": "31428-2261",
            "geo": {
                "lat": "-38.2386",
                "lng": "57.2232"
            }
        },
        "phone": "024-648-3804",
        "website": "ambrose.net",
        "company": {
            "name": "Hoeger LLC",
            "catchPhrase": "Centralized empowering task-force",
            "bs": "target end-to-end models"
        }
    } */
]);

const customUsers = {
    subscribe: users.subscribe,
    setUsers: (usersData) => {
        users.set(usersData);
    },
    addUser: () => {},
    updateUser: () => {},
    deleteUser: () => {}
};

/* node_modules\@smui\button\Button.svelte generated by Svelte v3.38.3 */
const file$7 = "node_modules\\@smui\\button\\Button.svelte";

// (50:10) {#if touch}
function create_if_block$3(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mdc-button__touch");
			add_location(div, file$7, 49, 21, 1522);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(50:10) {#if touch}",
		ctx
	});

	return block;
}

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: false,         color,         disabled: !!$$restProps.disabled,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-button': true,     'mdc-button--raised': variant === 'raised',     'mdc-button--unelevated': variant === 'unelevated',     'mdc-button--outlined': variant === 'outlined',     'smui-button--color-secondary': color === 'secondary',     'mdc-button--touch': touch,     'mdc-card__action': context === 'card:action',     'mdc-card__action--button': context === 'card:action',     'mdc-dialog__button': context === 'dialog:action',     'mdc-top-app-bar__navigation-icon': context === 'top-app-bar:navigation',     'mdc-top-app-bar__action-item': context === 'top-app-bar:action',     'mdc-snackbar__action': context === 'snackbar:actions',     'mdc-banner__secondary-action': context === 'banner' && secondary,     'mdc-banner__primary-action': context === 'banner' && !secondary,     'mdc-tooltip__action': context === 'tooltip:rich-actions',     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...actionProp}   {...defaultProp}   {...secondaryProp}   {href}   on:click={handleClick}   {...$$restProps}   >
function create_default_slot$3(ctx) {
	let div;
	let t;
	let if_block_anchor;
	let current;
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);
	let if_block = /*touch*/ ctx[6] && create_if_block$3(ctx);

	const block = {
		c: function create() {
			div = element("div");
			t = space();
			if (default_slot) default_slot.c();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			t = claim_space(nodes);
			if (default_slot) default_slot.l(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mdc-button__ripple");
			add_location(div, file$7, 48, 3, 1466);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 268435456)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[28], !current ? -1 : dirty, null, null);
				}
			}

			if (/*touch*/ ctx[6]) {
				if (if_block) ; else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: false,         color,         disabled: !!$$restProps.disabled,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-button': true,     'mdc-button--raised': variant === 'raised',     'mdc-button--unelevated': variant === 'unelevated',     'mdc-button--outlined': variant === 'outlined',     'smui-button--color-secondary': color === 'secondary',     'mdc-button--touch': touch,     'mdc-card__action': context === 'card:action',     'mdc-card__action--button': context === 'card:action',     'mdc-dialog__button': context === 'dialog:action',     'mdc-top-app-bar__navigation-icon': context === 'top-app-bar:navigation',     'mdc-top-app-bar__action-item': context === 'top-app-bar:action',     'mdc-snackbar__action': context === 'snackbar:actions',     'mdc-banner__secondary-action': context === 'banner' && secondary,     'mdc-banner__primary-action': context === 'banner' && !secondary,     'mdc-tooltip__action': context === 'tooltip:rich-actions',     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...actionProp}   {...defaultProp}   {...secondaryProp}   {href}   on:click={handleClick}   {...$$restProps}   >",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [
				[
					Ripple,
					{
						ripple: /*ripple*/ ctx[3],
						unbounded: false,
						color: /*color*/ ctx[4],
						disabled: !!/*$$restProps*/ ctx[22].disabled,
						addClass: /*addClass*/ ctx[18],
						removeClass: /*removeClass*/ ctx[19],
						addStyle: /*addStyle*/ ctx[20]
					}
				],
				/*forwardEvents*/ ctx[16],
				.../*use*/ ctx[0]
			]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button": true,
				"mdc-button--raised": /*variant*/ ctx[5] === "raised",
				"mdc-button--unelevated": /*variant*/ ctx[5] === "unelevated",
				"mdc-button--outlined": /*variant*/ ctx[5] === "outlined",
				"smui-button--color-secondary": /*color*/ ctx[4] === "secondary",
				"mdc-button--touch": /*touch*/ ctx[6],
				"mdc-card__action": /*context*/ ctx[17] === "card:action",
				"mdc-card__action--button": /*context*/ ctx[17] === "card:action",
				"mdc-dialog__button": /*context*/ ctx[17] === "dialog:action",
				"mdc-top-app-bar__navigation-icon": /*context*/ ctx[17] === "top-app-bar:navigation",
				"mdc-top-app-bar__action-item": /*context*/ ctx[17] === "top-app-bar:action",
				"mdc-snackbar__action": /*context*/ ctx[17] === "snackbar:actions",
				"mdc-banner__secondary-action": /*context*/ ctx[17] === "banner" && /*secondary*/ ctx[8],
				"mdc-banner__primary-action": /*context*/ ctx[17] === "banner" && !/*secondary*/ ctx[8],
				"mdc-tooltip__action": /*context*/ ctx[17] === "tooltip:rich-actions",
				.../*internalClasses*/ ctx[11]
			})
		},
		{
			style: Object.entries(/*internalStyles*/ ctx[12]).map(func$1).concat([/*style*/ ctx[2]]).join(" ")
		},
		/*actionProp*/ ctx[13],
		/*defaultProp*/ ctx[14],
		/*secondaryProp*/ ctx[15],
		{ href: /*href*/ ctx[7] },
		/*$$restProps*/ ctx[22]
	];

	var switch_value = /*component*/ ctx[9];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$3] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[27](switch_instance);
		switch_instance.$on("click", /*handleClick*/ ctx[21]);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*Ripple, ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use, classMap, className, variant, touch, context, secondary, internalClasses, Object, internalStyles, style, actionProp, defaultProp, secondaryProp, href*/ 6289919)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*Ripple, ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use*/ 6094873 && {
						use: [
							[
								Ripple,
								{
									ripple: /*ripple*/ ctx[3],
									unbounded: false,
									color: /*color*/ ctx[4],
									disabled: !!/*$$restProps*/ ctx[22].disabled,
									addClass: /*addClass*/ ctx[18],
									removeClass: /*removeClass*/ ctx[19],
									addStyle: /*addStyle*/ ctx[20]
								}
							],
							/*forwardEvents*/ ctx[16],
							.../*use*/ ctx[0]
						]
					},
					dirty & /*classMap, className, variant, color, touch, context, secondary, internalClasses*/ 133490 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button": true,
							"mdc-button--raised": /*variant*/ ctx[5] === "raised",
							"mdc-button--unelevated": /*variant*/ ctx[5] === "unelevated",
							"mdc-button--outlined": /*variant*/ ctx[5] === "outlined",
							"smui-button--color-secondary": /*color*/ ctx[4] === "secondary",
							"mdc-button--touch": /*touch*/ ctx[6],
							"mdc-card__action": /*context*/ ctx[17] === "card:action",
							"mdc-card__action--button": /*context*/ ctx[17] === "card:action",
							"mdc-dialog__button": /*context*/ ctx[17] === "dialog:action",
							"mdc-top-app-bar__navigation-icon": /*context*/ ctx[17] === "top-app-bar:navigation",
							"mdc-top-app-bar__action-item": /*context*/ ctx[17] === "top-app-bar:action",
							"mdc-snackbar__action": /*context*/ ctx[17] === "snackbar:actions",
							"mdc-banner__secondary-action": /*context*/ ctx[17] === "banner" && /*secondary*/ ctx[8],
							"mdc-banner__primary-action": /*context*/ ctx[17] === "banner" && !/*secondary*/ ctx[8],
							"mdc-tooltip__action": /*context*/ ctx[17] === "tooltip:rich-actions",
							.../*internalClasses*/ ctx[11]
						})
					},
					dirty & /*Object, internalStyles, style*/ 4100 && {
						style: Object.entries(/*internalStyles*/ ctx[12]).map(func$1).concat([/*style*/ ctx[2]]).join(" ")
					},
					dirty & /*actionProp*/ 8192 && get_spread_object(/*actionProp*/ ctx[13]),
					dirty & /*defaultProp*/ 16384 && get_spread_object(/*defaultProp*/ ctx[14]),
					dirty & /*secondaryProp*/ 32768 && get_spread_object(/*secondaryProp*/ ctx[15]),
					dirty & /*href*/ 128 && { href: /*href*/ ctx[7] },
					dirty & /*$$restProps*/ 4194304 && get_spread_object(/*$$restProps*/ ctx[22])
				])
			: {};

			if (dirty & /*$$scope, touch*/ 268435520) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[9])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[27](switch_instance);
					switch_instance.$on("click", /*handleClick*/ ctx[21]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[27](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const func$1 = ([name, value]) => `${name}: ${value};`;

function instance$8($$self, $$props, $$invalidate) {
	let actionProp;
	let defaultProp;
	let secondaryProp;

	const omit_props_names = [
		"use","class","style","ripple","color","variant","touch","href","action","default","secondary","component","getElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Button", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { style = "" } = $$props;
	let { ripple = true } = $$props;
	let { color = "primary" } = $$props;
	let { variant = "text" } = $$props;
	let { touch = false } = $$props;
	let { href = null } = $$props;
	let { action = "close" } = $$props;
	let { default: defaultAction = false } = $$props;
	let { secondary = false } = $$props;
	let element;
	let internalClasses = {};
	let internalStyles = {};
	let context = getContext("SMUI:button:context");
	let { component = href == null ? Button : A } = $$props;
	setContext("SMUI:label:context", "button");
	setContext("SMUI:icon:context", "button");

	function addClass(className) {
		if (!internalClasses[className]) {
			$$invalidate(11, internalClasses[className] = true, internalClasses);
		}
	}

	function removeClass(className) {
		if (!(className in internalClasses) || internalClasses[className]) {
			$$invalidate(11, internalClasses[className] = false, internalClasses);
		}
	}

	function addStyle(name, value) {
		if (internalStyles[name] != value) {
			if (value === "" || value == null) {
				delete internalStyles[name];
				$$invalidate(12, internalStyles);
			} else {
				$$invalidate(12, internalStyles[name] = value, internalStyles);
			}
		}
	}

	function handleClick() {
		if (context === "banner") {
			dispatch(getElement(), secondary
			? "SMUI:banner:button:secondaryActionClick"
			: "SMUI:banner:button:primaryActionClick");
		}
	}

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(10, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("style" in $$new_props) $$invalidate(2, style = $$new_props.style);
		if ("ripple" in $$new_props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("color" in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ("variant" in $$new_props) $$invalidate(5, variant = $$new_props.variant);
		if ("touch" in $$new_props) $$invalidate(6, touch = $$new_props.touch);
		if ("href" in $$new_props) $$invalidate(7, href = $$new_props.href);
		if ("action" in $$new_props) $$invalidate(23, action = $$new_props.action);
		if ("default" in $$new_props) $$invalidate(24, defaultAction = $$new_props.default);
		if ("secondary" in $$new_props) $$invalidate(8, secondary = $$new_props.secondary);
		if ("component" in $$new_props) $$invalidate(9, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		dispatch,
		Ripple,
		A,
		Button,
		forwardEvents,
		use,
		className,
		style,
		ripple,
		color,
		variant,
		touch,
		href,
		action,
		defaultAction,
		secondary,
		element,
		internalClasses,
		internalStyles,
		context,
		component,
		addClass,
		removeClass,
		addStyle,
		handleClick,
		getElement,
		actionProp,
		defaultProp,
		secondaryProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("style" in $$props) $$invalidate(2, style = $$new_props.style);
		if ("ripple" in $$props) $$invalidate(3, ripple = $$new_props.ripple);
		if ("color" in $$props) $$invalidate(4, color = $$new_props.color);
		if ("variant" in $$props) $$invalidate(5, variant = $$new_props.variant);
		if ("touch" in $$props) $$invalidate(6, touch = $$new_props.touch);
		if ("href" in $$props) $$invalidate(7, href = $$new_props.href);
		if ("action" in $$props) $$invalidate(23, action = $$new_props.action);
		if ("defaultAction" in $$props) $$invalidate(24, defaultAction = $$new_props.defaultAction);
		if ("secondary" in $$props) $$invalidate(8, secondary = $$new_props.secondary);
		if ("element" in $$props) $$invalidate(10, element = $$new_props.element);
		if ("internalClasses" in $$props) $$invalidate(11, internalClasses = $$new_props.internalClasses);
		if ("internalStyles" in $$props) $$invalidate(12, internalStyles = $$new_props.internalStyles);
		if ("context" in $$props) $$invalidate(17, context = $$new_props.context);
		if ("component" in $$props) $$invalidate(9, component = $$new_props.component);
		if ("actionProp" in $$props) $$invalidate(13, actionProp = $$new_props.actionProp);
		if ("defaultProp" in $$props) $$invalidate(14, defaultProp = $$new_props.defaultProp);
		if ("secondaryProp" in $$props) $$invalidate(15, secondaryProp = $$new_props.secondaryProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		$$invalidate(13, actionProp = context === "dialog:action" && action != null
		? { "data-mdc-dialog-action": action }
		: { action: $$props.action });

		$$invalidate(14, defaultProp = context === "dialog:action" && defaultAction
		? { "data-mdc-dialog-button-default": "" }
		: { default: $$props.default });

		$$invalidate(15, secondaryProp = context === "banner"
		? {}
		: { secondary: $$props.secondary });
	};

	$$props = exclude_internal_props($$props);

	return [
		use,
		className,
		style,
		ripple,
		color,
		variant,
		touch,
		href,
		secondary,
		component,
		element,
		internalClasses,
		internalStyles,
		actionProp,
		defaultProp,
		secondaryProp,
		forwardEvents,
		context,
		addClass,
		removeClass,
		addStyle,
		handleClick,
		$$restProps,
		action,
		defaultAction,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class Button_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$8, create_fragment$9, safe_not_equal, {
			use: 0,
			class: 1,
			style: 2,
			ripple: 3,
			color: 4,
			variant: 5,
			touch: 6,
			href: 7,
			action: 23,
			default: 24,
			secondary: 8,
			component: 9,
			getElement: 25
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button_1",
			options,
			id: create_fragment$9.name
		});
	}

	get use() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get variant() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variant(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get touch() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set touch(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get action() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set action(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get default() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set default(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get secondary() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set secondary(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[25];
	}

	set getElement(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\common\CommonLabel.svelte generated by Svelte v3.38.3 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>
function create_default_slot$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? -1 : dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button__label": /*context*/ ctx[5] === "button",
				"mdc-fab__label": /*context*/ ctx[5] === "fab",
				"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
				"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
				"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
				"mdc-banner__text": /*context*/ ctx[5] === "banner",
				"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
				"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
				"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
			})
		},
		/*context*/ ctx[5] === "snackbar"
		? { "aria-atomic": "false" }
		: {},
		{ tabindex: /*tabindex*/ ctx[6] },
		/*$$restProps*/ ctx[7]
	];

	var switch_value = /*component*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$2] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[10](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, context, tabindex, $$restProps*/ 243)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 17 && {
						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, context*/ 34 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button__label": /*context*/ ctx[5] === "button",
							"mdc-fab__label": /*context*/ ctx[5] === "fab",
							"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
							"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
							"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
							"mdc-banner__text": /*context*/ ctx[5] === "banner",
							"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
							"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
							"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
						})
					},
					dirty & /*context*/ 32 && get_spread_object(/*context*/ ctx[5] === "snackbar"
					? { "aria-atomic": "false" }
					: {}),
					dirty & /*tabindex*/ 64 && { tabindex: /*tabindex*/ ctx[6] },
					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
				])
			: {};

			if (dirty & /*$$scope*/ 2048) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[10](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[10](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonLabel", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let { component = Span } = $$props;
	const context = getContext("SMUI:label:context");
	const tabindex = getContext("SMUI:label:tabindex");

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		Span,
		forwardEvents,
		use,
		className,
		element,
		component,
		context,
		tabindex,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		component,
		element,
		forwardEvents,
		context,
		tabindex,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class CommonLabel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$8, safe_not_equal, {
			use: 0,
			class: 1,
			component: 2,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonLabel",
			options,
			id: create_fragment$8.name
		});
	}

	get use() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\UI\component\LoadingSpinner.svelte generated by Svelte v3.38.3 */

const file$6 = "src\\components\\UI\\component\\LoadingSpinner.svelte";

function create_fragment$7(ctx) {
	let div5;
	let div4;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;
	let t2;
	let div3;

	const block = {
		c: function create() {
			div5 = element("div");
			div4 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			t2 = space();
			div3 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			children(div1).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			children(div2).forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			children(div3).forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "svelte-1og1wa7");
			add_location(div0, file$6, 46, 8, 1120);
			attr_dev(div1, "class", "svelte-1og1wa7");
			add_location(div1, file$6, 47, 8, 1141);
			attr_dev(div2, "class", "svelte-1og1wa7");
			add_location(div2, file$6, 48, 8, 1162);
			attr_dev(div3, "class", "svelte-1og1wa7");
			add_location(div3, file$6, 49, 8, 1183);
			attr_dev(div4, "class", "lds-ring svelte-1og1wa7");
			add_location(div4, file$6, 45, 4, 1088);
			attr_dev(div5, "class", "loading svelte-1og1wa7");
			add_location(div5, file$6, 44, 0, 1061);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div4);
			append_dev(div4, div0);
			append_dev(div4, t0);
			append_dev(div4, div1);
			append_dev(div4, t1);
			append_dev(div4, div2);
			append_dev(div4, t2);
			append_dev(div4, div3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("LoadingSpinner", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LoadingSpinner> was created with unknown prop '${key}'`);
	});

	return [];
}

class LoadingSpinner extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadingSpinner",
			options,
			id: create_fragment$7.name
		});
	}
}

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * CSS class names used in component.
 */
var cssClasses = {
    CELL: 'mdc-data-table__cell',
    CELL_NUMERIC: 'mdc-data-table__cell--numeric',
    CONTENT: 'mdc-data-table__content',
    HEADER_CELL: 'mdc-data-table__header-cell',
    HEADER_CELL_LABEL: 'mdc-data-table__header-cell-label',
    HEADER_CELL_SORTED: 'mdc-data-table__header-cell--sorted',
    HEADER_CELL_SORTED_DESCENDING: 'mdc-data-table__header-cell--sorted-descending',
    HEADER_CELL_WITH_SORT: 'mdc-data-table__header-cell--with-sort',
    HEADER_CELL_WRAPPER: 'mdc-data-table__header-cell-wrapper',
    HEADER_ROW: 'mdc-data-table__header-row',
    HEADER_ROW_CHECKBOX: 'mdc-data-table__header-row-checkbox',
    IN_PROGRESS: 'mdc-data-table--in-progress',
    LINEAR_PROGRESS: 'mdc-data-table__linear-progress',
    PAGINATION_ROWS_PER_PAGE_LABEL: 'mdc-data-table__pagination-rows-per-page-label',
    PAGINATION_ROWS_PER_PAGE_SELECT: 'mdc-data-table__pagination-rows-per-page-select',
    PROGRESS_INDICATOR: 'mdc-data-table__progress-indicator',
    ROOT: 'mdc-data-table',
    ROW: 'mdc-data-table__row',
    ROW_CHECKBOX: 'mdc-data-table__row-checkbox',
    ROW_SELECTED: 'mdc-data-table__row--selected',
    SORT_ICON_BUTTON: 'mdc-data-table__sort-icon-button',
    SORT_STATUS_LABEL: 'mdc-data-table__sort-status-label',
    TABLE_CONTAINER: 'mdc-data-table__table-container',
};
/**
 * DOM attributes used in component.
 */
var attributes = {
    ARIA_SELECTED: 'aria-selected',
    ARIA_SORT: 'aria-sort',
};
/**
 * List of data attributes used in component.
 */
var dataAttributes = {
    COLUMN_ID: 'data-column-id',
    ROW_ID: 'data-row-id',
};
/**
 * CSS selectors used in component.
 */
var selectors = {
    CONTENT: "." + cssClasses.CONTENT,
    HEADER_CELL: "." + cssClasses.HEADER_CELL,
    HEADER_CELL_WITH_SORT: "." + cssClasses.HEADER_CELL_WITH_SORT,
    HEADER_ROW: "." + cssClasses.HEADER_ROW,
    HEADER_ROW_CHECKBOX: "." + cssClasses.HEADER_ROW_CHECKBOX,
    PROGRESS_INDICATOR: "." + cssClasses.PROGRESS_INDICATOR,
    ROW: "." + cssClasses.ROW,
    ROW_CHECKBOX: "." + cssClasses.ROW_CHECKBOX,
    ROW_SELECTED: "." + cssClasses.ROW_SELECTED,
    SORT_ICON_BUTTON: "." + cssClasses.SORT_ICON_BUTTON,
    SORT_STATUS_LABEL: "." + cssClasses.SORT_STATUS_LABEL,
};
/**
 * Attributes and selectors used in component.
 * @deprecated Use `attributes`, `dataAttributes` and `selectors` instead.
 */
var strings = {
    ARIA_SELECTED: attributes.ARIA_SELECTED,
    ARIA_SORT: attributes.ARIA_SORT,
    DATA_ROW_ID_ATTR: dataAttributes.ROW_ID,
    HEADER_ROW_CHECKBOX_SELECTOR: selectors.HEADER_ROW_CHECKBOX,
    ROW_CHECKBOX_SELECTOR: selectors.ROW_CHECKBOX,
    ROW_SELECTED_SELECTOR: selectors.ROW_SELECTED,
    ROW_SELECTOR: selectors.ROW,
};
/**
 * Sort values defined by ARIA.
 * See https://www.w3.org/WAI/PF/aria/states_and_properties#aria-sort
 */
var SortValue;
(function (SortValue) {
    // Items are sorted in ascending order by this column.
    SortValue["ASCENDING"] = "ascending";
    // Items are sorted in descending order by this column.
    SortValue["DESCENDING"] = "descending";
    // There is no defined sort applied to the column.
    SortValue["NONE"] = "none";
    // A sort algorithm other than ascending or descending has been applied.
    SortValue["OTHER"] = "other";
})(SortValue || (SortValue = {}));

/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * The Foundation of data table component containing pure business logic, any
 * logic requiring DOM manipulation are delegated to adapter methods.
 */
var MDCDataTableFoundation = /** @class */ (function (_super) {
    __extends(MDCDataTableFoundation, _super);
    function MDCDataTableFoundation(adapter) {
        return _super.call(this, __assign(__assign({}, MDCDataTableFoundation.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCDataTableFoundation, "defaultAdapter", {
        get: function () {
            return {
                addClass: function () { return undefined; },
                addClassAtRowIndex: function () { return undefined; },
                getAttributeByHeaderCellIndex: function () { return ''; },
                getHeaderCellCount: function () { return 0; },
                getHeaderCellElements: function () { return []; },
                getRowCount: function () { return 0; },
                getRowElements: function () { return []; },
                getRowIdAtIndex: function () { return ''; },
                getRowIndexByChildElement: function () { return 0; },
                getSelectedRowCount: function () { return 0; },
                getTableContainerHeight: function () { return 0; },
                getTableHeaderHeight: function () { return 0; },
                isCheckboxAtRowIndexChecked: function () { return false; },
                isHeaderRowCheckboxChecked: function () { return false; },
                isRowsSelectable: function () { return false; },
                notifyRowSelectionChanged: function () { return undefined; },
                notifySelectedAll: function () { return undefined; },
                notifySortAction: function () { return undefined; },
                notifyUnselectedAll: function () { return undefined; },
                registerHeaderRowCheckbox: function () { return undefined; },
                registerRowCheckboxes: function () { return undefined; },
                removeClass: function () { return undefined; },
                removeClassAtRowIndex: function () { return undefined; },
                removeClassNameByHeaderCellIndex: function () { return undefined; },
                setAttributeAtRowIndex: function () { return undefined; },
                setAttributeByHeaderCellIndex: function () { return undefined; },
                setClassNameByHeaderCellIndex: function () { return undefined; },
                setHeaderRowCheckboxChecked: function () { return undefined; },
                setHeaderRowCheckboxIndeterminate: function () { return undefined; },
                setProgressIndicatorStyles: function () { return undefined; },
                setRowCheckboxCheckedAtIndex: function () { return undefined; },
                setSortStatusLabelByHeaderCellIndex: function () { return undefined; },
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     * Use this if registering checkbox is synchronous.
     */
    MDCDataTableFoundation.prototype.layout = function () {
        if (this.adapter.isRowsSelectable()) {
            this.adapter.registerHeaderRowCheckbox();
            this.adapter.registerRowCheckboxes();
            this.setHeaderRowCheckboxState();
        }
    };
    /**
     * Re-initializes header row checkbox and row checkboxes when selectable rows are added or removed from table.
     * Use this if registering checkbox is asynchronous.
     */
    MDCDataTableFoundation.prototype.layoutAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.adapter.isRowsSelectable()) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.adapter.registerHeaderRowCheckbox()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.adapter.registerRowCheckboxes()];
                    case 2:
                        _a.sent();
                        this.setHeaderRowCheckboxState();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @return Returns array of row elements.
     */
    MDCDataTableFoundation.prototype.getRows = function () {
        return this.adapter.getRowElements();
    };
    /**
     * @return Array of header cell elements.
     */
    MDCDataTableFoundation.prototype.getHeaderCells = function () {
        return this.adapter.getHeaderCellElements();
    };
    /**
     * Sets selected row ids. Overwrites previously selected rows.
     * @param rowIds Array of row ids that needs to be selected.
     */
    MDCDataTableFoundation.prototype.setSelectedRowIds = function (rowIds) {
        for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
            var rowId = this.adapter.getRowIdAtIndex(rowIndex);
            var isSelected = false;
            if (rowId && rowIds.indexOf(rowId) >= 0) {
                isSelected = true;
            }
            this.adapter.setRowCheckboxCheckedAtIndex(rowIndex, isSelected);
            this.selectRowAtIndex(rowIndex, isSelected);
        }
        this.setHeaderRowCheckboxState();
    };
    /**
     * @return Returns array of all row ids.
     */
    MDCDataTableFoundation.prototype.getRowIds = function () {
        var rowIds = [];
        for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
            rowIds.push(this.adapter.getRowIdAtIndex(rowIndex));
        }
        return rowIds;
    };
    /**
     * @return Returns array of selected row ids.
     */
    MDCDataTableFoundation.prototype.getSelectedRowIds = function () {
        var selectedRowIds = [];
        for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
            if (this.adapter.isCheckboxAtRowIndexChecked(rowIndex)) {
                selectedRowIds.push(this.adapter.getRowIdAtIndex(rowIndex));
            }
        }
        return selectedRowIds;
    };
    /**
     * Handles header row checkbox change event.
     */
    MDCDataTableFoundation.prototype.handleHeaderRowCheckboxChange = function () {
        var isHeaderChecked = this.adapter.isHeaderRowCheckboxChecked();
        for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
            this.adapter.setRowCheckboxCheckedAtIndex(rowIndex, isHeaderChecked);
            this.selectRowAtIndex(rowIndex, isHeaderChecked);
        }
        if (isHeaderChecked) {
            this.adapter.notifySelectedAll();
        }
        else {
            this.adapter.notifyUnselectedAll();
        }
    };
    /**
     * Handles change event originated from row checkboxes.
     */
    MDCDataTableFoundation.prototype.handleRowCheckboxChange = function (event) {
        var rowIndex = this.adapter.getRowIndexByChildElement(event.target);
        if (rowIndex === -1) {
            return;
        }
        var selected = this.adapter.isCheckboxAtRowIndexChecked(rowIndex);
        this.selectRowAtIndex(rowIndex, selected);
        this.setHeaderRowCheckboxState();
        var rowId = this.adapter.getRowIdAtIndex(rowIndex);
        this.adapter.notifyRowSelectionChanged({ rowId: rowId, rowIndex: rowIndex, selected: selected });
    };
    /**
     * Handles sort action on sortable header cell.
     */
    MDCDataTableFoundation.prototype.handleSortAction = function (eventData) {
        var columnId = eventData.columnId, columnIndex = eventData.columnIndex, headerCell = eventData.headerCell;
        // Reset sort attributes / classes on other header cells.
        for (var index = 0; index < this.adapter.getHeaderCellCount(); index++) {
            if (index === columnIndex) {
                continue;
            }
            this.adapter.removeClassNameByHeaderCellIndex(index, cssClasses.HEADER_CELL_SORTED);
            this.adapter.removeClassNameByHeaderCellIndex(index, cssClasses.HEADER_CELL_SORTED_DESCENDING);
            this.adapter.setAttributeByHeaderCellIndex(index, strings.ARIA_SORT, SortValue.NONE);
            this.adapter.setSortStatusLabelByHeaderCellIndex(index, SortValue.NONE);
        }
        // Set appropriate sort attributes / classes on target header cell.
        this.adapter.setClassNameByHeaderCellIndex(columnIndex, cssClasses.HEADER_CELL_SORTED);
        var currentSortValue = this.adapter.getAttributeByHeaderCellIndex(columnIndex, strings.ARIA_SORT);
        var sortValue = SortValue.NONE;
        // Set to descending if sorted on ascending order.
        if (currentSortValue === SortValue.ASCENDING) {
            this.adapter.setClassNameByHeaderCellIndex(columnIndex, cssClasses.HEADER_CELL_SORTED_DESCENDING);
            this.adapter.setAttributeByHeaderCellIndex(columnIndex, strings.ARIA_SORT, SortValue.DESCENDING);
            sortValue = SortValue.DESCENDING;
            // Set to ascending if sorted on descending order.
        }
        else if (currentSortValue === SortValue.DESCENDING) {
            this.adapter.removeClassNameByHeaderCellIndex(columnIndex, cssClasses.HEADER_CELL_SORTED_DESCENDING);
            this.adapter.setAttributeByHeaderCellIndex(columnIndex, strings.ARIA_SORT, SortValue.ASCENDING);
            sortValue = SortValue.ASCENDING;
        }
        else {
            // Set to ascending by default when not sorted.
            this.adapter.setAttributeByHeaderCellIndex(columnIndex, strings.ARIA_SORT, SortValue.ASCENDING);
            sortValue = SortValue.ASCENDING;
        }
        this.adapter.setSortStatusLabelByHeaderCellIndex(columnIndex, sortValue);
        this.adapter.notifySortAction({
            columnId: columnId,
            columnIndex: columnIndex,
            headerCell: headerCell,
            sortValue: sortValue,
        });
    };
    /**
     * Shows progress indicator blocking only the table body content when in
     * loading state.
     */
    MDCDataTableFoundation.prototype.showProgress = function () {
        var tableHeaderHeight = this.adapter.getTableHeaderHeight();
        // Calculate the height of table content (Not scroll content) excluding
        // header row height.
        var height = this.adapter.getTableContainerHeight() - tableHeaderHeight;
        var top = tableHeaderHeight;
        this.adapter.setProgressIndicatorStyles({
            height: height + "px",
            top: top + "px",
        });
        this.adapter.addClass(cssClasses.IN_PROGRESS);
    };
    /**
     * Hides progress indicator when data table is finished loading.
     */
    MDCDataTableFoundation.prototype.hideProgress = function () {
        this.adapter.removeClass(cssClasses.IN_PROGRESS);
    };
    /**
     * Updates header row checkbox state based on number of rows selected.
     */
    MDCDataTableFoundation.prototype.setHeaderRowCheckboxState = function () {
        if (this.adapter.getSelectedRowCount() === 0) {
            this.adapter.setHeaderRowCheckboxChecked(false);
            this.adapter.setHeaderRowCheckboxIndeterminate(false);
        }
        else if (this.adapter.getSelectedRowCount() === this.adapter.getRowCount()) {
            this.adapter.setHeaderRowCheckboxChecked(true);
            this.adapter.setHeaderRowCheckboxIndeterminate(false);
        }
        else {
            this.adapter.setHeaderRowCheckboxIndeterminate(true);
            this.adapter.setHeaderRowCheckboxChecked(false);
        }
    };
    /**
     * Sets the attributes of row element based on selection state.
     */
    MDCDataTableFoundation.prototype.selectRowAtIndex = function (rowIndex, selected) {
        if (selected) {
            this.adapter.addClassAtRowIndex(rowIndex, cssClasses.ROW_SELECTED);
            this.adapter.setAttributeAtRowIndex(rowIndex, strings.ARIA_SELECTED, 'true');
        }
        else {
            this.adapter.removeClassAtRowIndex(rowIndex, cssClasses.ROW_SELECTED);
            this.adapter.setAttributeAtRowIndex(rowIndex, strings.ARIA_SELECTED, 'false');
        }
    };
    return MDCDataTableFoundation;
}(MDCFoundation));

/* node_modules\@smui\data-table\DataTable.svelte generated by Svelte v3.38.3 */

const { Error: Error_1 } = globals;

const file$5 = "node_modules\\@smui\\data-table\\DataTable.svelte";
const get_paginate_slot_changes = dirty => ({});
const get_paginate_slot_context = ctx => ({});
const get_progress_slot_changes = dirty => ({});
const get_progress_slot_context = ctx => ({});

// (44:2) {#if $$slots.progress}
function create_if_block$2(ctx) {
	let div1;
	let div0;
	let t;
	let div1_style_value;
	let current;
	const progress_slot_template = /*#slots*/ ctx[32].progress;
	const progress_slot = create_slot(progress_slot_template, ctx, /*$$scope*/ ctx[31], get_progress_slot_context);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (progress_slot) progress_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t = claim_space(div1_nodes);
			if (progress_slot) progress_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "mdc-data-table__scrim");
			add_location(div0, file$5, 50, 6, 1583);
			attr_dev(div1, "class", "mdc-data-table__progress-indicator");
			attr_dev(div1, "style", div1_style_value = Object.entries(/*progressIndicatorStyles*/ ctx[13]).map(func).join(" "));
			add_location(div1, file$5, 44, 4, 1390);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div1, t);

			if (progress_slot) {
				progress_slot.m(div1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (progress_slot) {
				if (progress_slot.p && (!current || dirty[1] & /*$$scope*/ 1)) {
					update_slot(progress_slot, progress_slot_template, ctx, /*$$scope*/ ctx[31], !current ? [-1, -1] : dirty, get_progress_slot_changes, get_progress_slot_context);
				}
			}

			if (!current || dirty[0] & /*progressIndicatorStyles*/ 8192 && div1_style_value !== (div1_style_value = Object.entries(/*progressIndicatorStyles*/ ctx[13]).map(func).join(" "))) {
				attr_dev(div1, "style", div1_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(progress_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(progress_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (progress_slot) progress_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(44:2) {#if $$slots.progress}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div1;
	let div0;
	let table;
	let table_class_value;
	let useActions_action;
	let div0_class_value;
	let useActions_action_1;
	let t0;
	let t1;
	let div1_class_value;
	let useActions_action_2;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[32].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[31], null);

	let table_levels = [
		{
			class: table_class_value = classMap({
				[/*table$class*/ ctx[6]]: true,
				"mdc-data-table__table": true
			})
		},
		prefixFilter(/*$$restProps*/ ctx[21], "table$")
	];

	let table_data = {};

	for (let i = 0; i < table_levels.length; i += 1) {
		table_data = assign(table_data, table_levels[i]);
	}

	let div0_levels = [
		{
			class: div0_class_value = classMap({
				[/*container$class*/ ctx[4]]: true,
				"mdc-data-table__table-container": true
			})
		},
		prefixFilter(/*$$restProps*/ ctx[21], "container$")
	];

	let div0_data = {};

	for (let i = 0; i < div0_levels.length; i += 1) {
		div0_data = assign(div0_data, div0_levels[i]);
	}

	let if_block = /*$$slots*/ ctx[20].progress && create_if_block$2(ctx);
	const paginate_slot_template = /*#slots*/ ctx[32].paginate;
	const paginate_slot = create_slot(paginate_slot_template, ctx, /*$$scope*/ ctx[31], get_paginate_slot_context);

	let div1_levels = [
		{
			class: div1_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-data-table": true,
				"mdc-data-table--sticky-header": /*stickyHeader*/ ctx[2],
				.../*internalClasses*/ ctx[12]
			})
		},
		exclude(/*$$restProps*/ ctx[21], ["container$", "table$"])
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			table = element("table");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			if (paginate_slot) paginate_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			table = claim_element(div0_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			if (default_slot) default_slot.l(table_nodes);
			table_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			if (paginate_slot) paginate_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(table, table_data);
			add_location(table, file$5, 31, 4, 1128);
			set_attributes(div0, div0_data);
			add_location(div0, file$5, 22, 2, 897);
			set_attributes(div1, div1_data);
			add_location(div1, file$5, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, table);

			if (default_slot) {
				default_slot.m(table, null);
			}

			/*div0_binding*/ ctx[33](div0);
			append_dev(div1, t0);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t1);

			if (paginate_slot) {
				paginate_slot.m(div1, null);
			}

			/*div1_binding*/ ctx[34](div1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, table, /*table$use*/ ctx[5])),
					action_destroyer(useActions_action_1 = useActions.call(null, div0, /*container$use*/ ctx[3])),
					action_destroyer(useActions_action_2 = useActions.call(null, div1, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[15].call(null, div1)),
					listen_dev(div1, "SMUI:checkbox:mount", /*SMUI_checkbox_mount_handler*/ ctx[35], false, false, false),
					listen_dev(div1, "SMUI:data-table:header:mount", /*SMUI_data_table_header_mount_handler*/ ctx[36], false, false, false),
					listen_dev(div1, "SMUI:data-table:header:unmount", /*SMUI_data_table_header_unmount_handler*/ ctx[37], false, false, false),
					listen_dev(div1, "SMUI:data-table:body:mount", /*SMUI_data_table_body_mount_handler*/ ctx[38], false, false, false),
					listen_dev(div1, "SMUI:data-table:body:unmount", /*SMUI_data_table_body_unmount_handler*/ ctx[39], false, false, false),
					listen_dev(div1, "SMUI:data-table:header:checkbox:change", /*SMUI_data_table_header_checkbox_change_handler*/ ctx[40], false, false, false),
					listen_dev(div1, "SMUI:data-table:header:click", /*handleHeaderRowClick*/ ctx[19], false, false, false),
					listen_dev(div1, "SMUI:data-table:body:checkbox:change", /*SMUI_data_table_body_checkbox_change_handler*/ ctx[41], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[31], !current ? [-1, -1] : dirty, null, null);
				}
			}

			set_attributes(table, table_data = get_spread_update(table_levels, [
				(!current || dirty[0] & /*table$class*/ 64 && table_class_value !== (table_class_value = classMap({
					[/*table$class*/ ctx[6]]: true,
					"mdc-data-table__table": true
				}))) && { class: table_class_value },
				dirty[0] & /*$$restProps*/ 2097152 && prefixFilter(/*$$restProps*/ ctx[21], "table$")
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*table$use*/ 32) useActions_action.update.call(null, /*table$use*/ ctx[5]);

			set_attributes(div0, div0_data = get_spread_update(div0_levels, [
				(!current || dirty[0] & /*container$class*/ 16 && div0_class_value !== (div0_class_value = classMap({
					[/*container$class*/ ctx[4]]: true,
					"mdc-data-table__table-container": true
				}))) && { class: div0_class_value },
				dirty[0] & /*$$restProps*/ 2097152 && prefixFilter(/*$$restProps*/ ctx[21], "container$")
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*container$use*/ 8) useActions_action_1.update.call(null, /*container$use*/ ctx[3]);

			if (/*$$slots*/ ctx[20].progress) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*$$slots*/ 1048576) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (paginate_slot) {
				if (paginate_slot.p && (!current || dirty[1] & /*$$scope*/ 1)) {
					update_slot(paginate_slot, paginate_slot_template, ctx, /*$$scope*/ ctx[31], !current ? [-1, -1] : dirty, get_paginate_slot_changes, get_paginate_slot_context);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty[0] & /*className, stickyHeader, internalClasses*/ 4102 && div1_class_value !== (div1_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-data-table": true,
					"mdc-data-table--sticky-header": /*stickyHeader*/ ctx[2],
					.../*internalClasses*/ ctx[12]
				}))) && { class: div1_class_value },
				dirty[0] & /*$$restProps*/ 2097152 && exclude(/*$$restProps*/ ctx[21], ["container$", "table$"])
			]));

			if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & /*use*/ 1) useActions_action_2.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			transition_in(paginate_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			transition_out(paginate_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[33](null);
			if (if_block) if_block.d();
			if (paginate_slot) paginate_slot.d(detaching);
			/*div1_binding*/ ctx[34](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const func = ([name, value]) => `${name}: ${value};`;

function instance_1($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"use","class","stickyHeader","sortable","sort","sortDirection","sortAscendingAriaLabel","sortDescendingAriaLabel","container$use","container$class","table$use","table$class","layout","getElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $sortStore;
	let $sortDirectionStore;
	let $progressClosed;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DataTable", slots, ['default','progress','paginate']);
	const $$slots = compute_slots(slots);
	const { closest } = ponyfill;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { stickyHeader = false } = $$props;
	let { sortable = false } = $$props;
	let { sort = null } = $$props;
	let { sortDirection = "ascending" } = $$props;
	let { sortAscendingAriaLabel = "sorted, ascending" } = $$props;
	let { sortDescendingAriaLabel = "sorted, descending" } = $$props;
	let { container$use = [] } = $$props;
	let { container$class = "" } = $$props;
	let { table$use = [] } = $$props;
	let { table$class = "" } = $$props;
	let element;
	let instance;
	let container;
	let header;
	let body;
	let internalClasses = {};
	let progressIndicatorStyles = {};
	let addLayoutListener = getContext("SMUI:addLayoutListener");
	let removeLayoutListener;
	let postMount = false;
	let progressClosed = writable(false);
	validate_store(progressClosed, "progressClosed");
	component_subscribe($$self, progressClosed, value => $$invalidate(30, $progressClosed = value));
	let sortStore = writable(sort);
	validate_store(sortStore, "sortStore");
	component_subscribe($$self, sortStore, value => $$invalidate(43, $sortStore = value));
	let sortDirectionStore = writable(sortDirection);
	validate_store(sortDirectionStore, "sortDirectionStore");
	component_subscribe($$self, sortDirectionStore, value => $$invalidate(44, $sortDirectionStore = value));
	setContext("SMUI:checkbox:context", "data-table");
	setContext("SMUI:linear-progress:context", "data-table");
	setContext("SMUI:linear-progress:closed", progressClosed);
	setContext("SMUI:data-table:sortable", sortable);
	setContext("SMUI:data-table:sort", sortStore);
	setContext("SMUI:data-table:sortDirection", sortDirectionStore);
	setContext("SMUI:data-table:sortAscendingAriaLabel", sortAscendingAriaLabel);
	setContext("SMUI:data-table:sortDescendingAriaLabel", sortDescendingAriaLabel);

	if (addLayoutListener) {
		removeLayoutListener = addLayoutListener(layout);
	}

	let previousProgressClosed = null;

	onMount(() => {
		$$invalidate(7, instance = new MDCDataTableFoundation({
				addClass,
				removeClass,
				getHeaderCellElements: () => header.cells.map(accessor => accessor.element),
				getHeaderCellCount: () => header.cells.length,
				getAttributeByHeaderCellIndex: (index, name) => {
					return header.orderedCells[index].getAttr(name);
				},
				setAttributeByHeaderCellIndex: (index, name, value) => {
					header.orderedCells[index].addAttr(name, value);
				},
				setClassNameByHeaderCellIndex: (index, className) => {
					header.orderedCells[index].addClass(className);
				},
				removeClassNameByHeaderCellIndex: (index, className) => {
					header.orderedCells[index].removeClass(className);
				},
				notifySortAction: data => {
					$$invalidate(22, sort = data.columnId);
					$$invalidate(23, sortDirection = data.sortValue);
					dispatch(getElement(), "MDCDataTable:sorted", data);
				},
				getTableContainerHeight: () => container.getBoundingClientRect().height,
				getTableHeaderHeight: () => {
					const tableHeader = getElement().querySelector(".mdc-data-table__header-row");

					if (!tableHeader) {
						throw new Error("MDCDataTable: Table header element not found.");
					}

					return tableHeader.getBoundingClientRect().height;
				},
				setProgressIndicatorStyles: styles => {
					$$invalidate(13, progressIndicatorStyles = styles);
				},
				addClassAtRowIndex: (rowIndex, className) => {
					body.orderedRows[rowIndex].addClass(className);
				},
				getRowCount: () => body.rows.length,
				getRowElements: () => body.rows.map(accessor => accessor.element),
				getRowIdAtIndex: rowIndex => body.orderedRows[rowIndex].rowId,
				getRowIndexByChildElement: el => {
					return body.orderedRows.map(accessor => accessor.element).indexOf(closest(el, ".mdc-data-table__row"));
				},
				getSelectedRowCount: () => body.rows.filter(accessor => accessor.selected).length,
				isCheckboxAtRowIndexChecked: rowIndex => {
					const checkbox = body.orderedRows[rowIndex].checkbox;

					if (checkbox) {
						return checkbox.checked;
					}

					return false;
				},
				isHeaderRowCheckboxChecked: () => {
					const checkbox = header.checkbox;

					if (checkbox) {
						return checkbox.checked;
					}

					return false;
				},
				isRowsSelectable: () => !!getElement().querySelector(".mdc-data-table__row-checkbox") || !!getElement().querySelector(".mdc-data-table__header-row-checkbox"),
				notifyRowSelectionChanged: data => {
					const row = body.orderedRows[data.rowIndex];

					dispatch(getElement(), "MDCDataTable:rowSelectionChanged", {
						row: row.element,
						rowId: row.rowId,
						rowIndex: data.rowIndex,
						selected: data.selected
					});
				},
				notifySelectedAll: () => {
					setHeaderRowCheckboxIndeterminate(false);
					dispatch(getElement(), "MDCDataTable:selectedAll");
				},
				notifyUnselectedAll: () => {
					setHeaderRowCheckboxIndeterminate(false);
					dispatch(getElement(), "MDCDataTable:unselectedAll");
				},
				registerHeaderRowCheckbox: () => {
					
				}, // Handled automatically.
				registerRowCheckboxes: () => {
					
				}, // Handled automatically.
				removeClassAtRowIndex: (rowIndex, className) => {
					body.orderedRows[rowIndex].removeClass(className);
				},
				setAttributeAtRowIndex: (rowIndex, name, value) => {
					body.orderedRows[rowIndex].addAttr(name, value);
				},
				setHeaderRowCheckboxChecked: checked => {
					const checkbox = header.checkbox;

					if (checkbox) {
						checkbox.checked = checked;
					}
				},
				setHeaderRowCheckboxIndeterminate,
				setRowCheckboxCheckedAtIndex: (rowIndex, checked) => {
					const checkbox = body.orderedRows[rowIndex].checkbox;

					if (checkbox) {
						checkbox.checked = checked;
					}
				},
				setSortStatusLabelByHeaderCellIndex: (_columnIndex, _sortValue) => {
					
				}, // Handled automatically.
				
			}));

		instance.init();
		instance.layout();
		$$invalidate(14, postMount = true);

		return () => {
			instance.destroy();
		};
	});

	onDestroy(() => {
		if (removeLayoutListener) {
			removeLayoutListener();
		}
	});

	function addClass(className) {
		if (!internalClasses[className]) {
			$$invalidate(12, internalClasses[className] = true, internalClasses);
		}
	}

	function removeClass(className) {
		if (!(className in internalClasses) || internalClasses[className]) {
			$$invalidate(12, internalClasses[className] = false, internalClasses);
		}
	}

	function setHeaderRowCheckboxIndeterminate(indeterminate) {
		const checkbox = header.checkbox;

		if (checkbox) {
			checkbox.indeterminate = indeterminate;
		}
	}

	function handleHeaderRowClick(event) {
		if (!instance) {
			return;
		}

		const headerCell = closest(event.detail.target, ".mdc-data-table__header-cell--with-sort");

		if (!headerCell) {
			return;
		}

		const orderedCells = header.orderedCells;
		const columnIndex = orderedCells.map(accessor => accessor.element).indexOf(headerCell);

		if (columnIndex === -1) {
			return;
		}

		const columnId = orderedCells[columnIndex].columnId;
		instance.handleSortAction({ columnId, columnIndex, headerCell });
	}

	function layout() {
		return instance.layout();
	}

	function getElement() {
		return element;
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(9, container);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(8, element);
		});
	}

	const SMUI_checkbox_mount_handler = () => instance && postMount && instance.layout();
	const SMUI_data_table_header_mount_handler = event => $$invalidate(10, header = event.detail);
	const SMUI_data_table_header_unmount_handler = () => $$invalidate(10, header = undefined);
	const SMUI_data_table_body_mount_handler = event => $$invalidate(11, body = event.detail);
	const SMUI_data_table_body_unmount_handler = () => $$invalidate(11, body = undefined);
	const SMUI_data_table_header_checkbox_change_handler = () => instance && instance.handleHeaderRowCheckboxChange();
	const SMUI_data_table_body_checkbox_change_handler = event => instance && instance.handleRowCheckboxChange(event);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("stickyHeader" in $$new_props) $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
		if ("sortable" in $$new_props) $$invalidate(24, sortable = $$new_props.sortable);
		if ("sort" in $$new_props) $$invalidate(22, sort = $$new_props.sort);
		if ("sortDirection" in $$new_props) $$invalidate(23, sortDirection = $$new_props.sortDirection);
		if ("sortAscendingAriaLabel" in $$new_props) $$invalidate(25, sortAscendingAriaLabel = $$new_props.sortAscendingAriaLabel);
		if ("sortDescendingAriaLabel" in $$new_props) $$invalidate(26, sortDescendingAriaLabel = $$new_props.sortDescendingAriaLabel);
		if ("container$use" in $$new_props) $$invalidate(3, container$use = $$new_props.container$use);
		if ("container$class" in $$new_props) $$invalidate(4, container$class = $$new_props.container$class);
		if ("table$use" in $$new_props) $$invalidate(5, table$use = $$new_props.table$use);
		if ("table$class" in $$new_props) $$invalidate(6, table$class = $$new_props.table$class);
		if ("$$scope" in $$new_props) $$invalidate(31, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		MDCDataTableFoundation,
		ponyfill,
		onMount,
		onDestroy,
		getContext,
		setContext,
		writable,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		exclude,
		prefixFilter,
		useActions,
		dispatch,
		closest,
		forwardEvents,
		use,
		className,
		stickyHeader,
		sortable,
		sort,
		sortDirection,
		sortAscendingAriaLabel,
		sortDescendingAriaLabel,
		container$use,
		container$class,
		table$use,
		table$class,
		element,
		instance,
		container,
		header,
		body,
		internalClasses,
		progressIndicatorStyles,
		addLayoutListener,
		removeLayoutListener,
		postMount,
		progressClosed,
		sortStore,
		sortDirectionStore,
		previousProgressClosed,
		addClass,
		removeClass,
		setHeaderRowCheckboxIndeterminate,
		handleHeaderRowClick,
		layout,
		getElement,
		$sortStore,
		$sortDirectionStore,
		$progressClosed
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("stickyHeader" in $$props) $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
		if ("sortable" in $$props) $$invalidate(24, sortable = $$new_props.sortable);
		if ("sort" in $$props) $$invalidate(22, sort = $$new_props.sort);
		if ("sortDirection" in $$props) $$invalidate(23, sortDirection = $$new_props.sortDirection);
		if ("sortAscendingAriaLabel" in $$props) $$invalidate(25, sortAscendingAriaLabel = $$new_props.sortAscendingAriaLabel);
		if ("sortDescendingAriaLabel" in $$props) $$invalidate(26, sortDescendingAriaLabel = $$new_props.sortDescendingAriaLabel);
		if ("container$use" in $$props) $$invalidate(3, container$use = $$new_props.container$use);
		if ("container$class" in $$props) $$invalidate(4, container$class = $$new_props.container$class);
		if ("table$use" in $$props) $$invalidate(5, table$use = $$new_props.table$use);
		if ("table$class" in $$props) $$invalidate(6, table$class = $$new_props.table$class);
		if ("element" in $$props) $$invalidate(8, element = $$new_props.element);
		if ("instance" in $$props) $$invalidate(7, instance = $$new_props.instance);
		if ("container" in $$props) $$invalidate(9, container = $$new_props.container);
		if ("header" in $$props) $$invalidate(10, header = $$new_props.header);
		if ("body" in $$props) $$invalidate(11, body = $$new_props.body);
		if ("internalClasses" in $$props) $$invalidate(12, internalClasses = $$new_props.internalClasses);
		if ("progressIndicatorStyles" in $$props) $$invalidate(13, progressIndicatorStyles = $$new_props.progressIndicatorStyles);
		if ("addLayoutListener" in $$props) addLayoutListener = $$new_props.addLayoutListener;
		if ("removeLayoutListener" in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
		if ("postMount" in $$props) $$invalidate(14, postMount = $$new_props.postMount);
		if ("progressClosed" in $$props) $$invalidate(16, progressClosed = $$new_props.progressClosed);
		if ("sortStore" in $$props) $$invalidate(17, sortStore = $$new_props.sortStore);
		if ("sortDirectionStore" in $$props) $$invalidate(18, sortDirectionStore = $$new_props.sortDirectionStore);
		if ("previousProgressClosed" in $$props) $$invalidate(29, previousProgressClosed = $$new_props.previousProgressClosed);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*sort*/ 4194304) {
			set_store_value(sortStore, $sortStore = sort, $sortStore);
		}

		if ($$self.$$.dirty[0] & /*sortDirection*/ 8388608) {
			set_store_value(sortDirectionStore, $sortDirectionStore = sortDirection, $sortDirectionStore);
		}

		if ($$self.$$.dirty[0] & /*instance, previousProgressClosed, $progressClosed*/ 1610612864) {
			if ($$slots.progress && instance && previousProgressClosed !== $progressClosed) {
				$$invalidate(29, previousProgressClosed = $progressClosed);

				if ($progressClosed) {
					instance.hideProgress();
				} else {
					instance.showProgress();
				}
			}
		}
	};

	return [
		use,
		className,
		stickyHeader,
		container$use,
		container$class,
		table$use,
		table$class,
		instance,
		element,
		container,
		header,
		body,
		internalClasses,
		progressIndicatorStyles,
		postMount,
		forwardEvents,
		progressClosed,
		sortStore,
		sortDirectionStore,
		handleHeaderRowClick,
		$$slots,
		$$restProps,
		sort,
		sortDirection,
		sortable,
		sortAscendingAriaLabel,
		sortDescendingAriaLabel,
		layout,
		getElement,
		previousProgressClosed,
		$progressClosed,
		$$scope,
		slots,
		div0_binding,
		div1_binding,
		SMUI_checkbox_mount_handler,
		SMUI_data_table_header_mount_handler,
		SMUI_data_table_header_unmount_handler,
		SMUI_data_table_body_mount_handler,
		SMUI_data_table_body_unmount_handler,
		SMUI_data_table_header_checkbox_change_handler,
		SMUI_data_table_body_checkbox_change_handler
	];
}

class DataTable extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1,
			create_fragment$6,
			safe_not_equal,
			{
				use: 0,
				class: 1,
				stickyHeader: 2,
				sortable: 24,
				sort: 22,
				sortDirection: 23,
				sortAscendingAriaLabel: 25,
				sortDescendingAriaLabel: 26,
				container$use: 3,
				container$class: 4,
				table$use: 5,
				table$class: 6,
				layout: 27,
				getElement: 28
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DataTable",
			options,
			id: create_fragment$6.name
		});
	}

	get use() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stickyHeader() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stickyHeader(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sort() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sort(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortDirection() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortDirection(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortAscendingAriaLabel() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortAscendingAriaLabel(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortDescendingAriaLabel() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortDescendingAriaLabel(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container$use() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container$use(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container$class() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container$class(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get table$use() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table$use(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get table$class() {
		throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table$class(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get layout() {
		return this.$$.ctx[27];
	}

	set layout(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[28];
	}

	set getElement(value) {
		throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Head.svelte generated by Svelte v3.38.3 */

const file$4 = "node_modules\\@smui\\data-table\\Head.svelte";

function create_fragment$5(ctx) {
	let thead;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let thead_levels = [/*$$restProps*/ ctx[6]];
	let thead_data = {};

	for (let i = 0; i < thead_levels.length; i += 1) {
		thead_data = assign(thead_data, thead_levels[i]);
	}

	const block = {
		c: function create() {
			thead = element("thead");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			thead = claim_element(nodes, "THEAD", {});
			var thead_nodes = children(thead);
			if (default_slot) default_slot.l(thead_nodes);
			thead_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(thead, thead_data);
			add_location(thead, file$4, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, thead, anchor);

			if (default_slot) {
				default_slot.m(thead, null);
			}

			/*thead_binding*/ ctx[10](thead);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, thead, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[3].call(null, thead)),
					listen_dev(thead, "SMUI:checkbox:mount", /*SMUI_checkbox_mount_handler*/ ctx[11], false, false, false),
					listen_dev(thead, "SMUI:checkbox:unmount", /*SMUI_checkbox_unmount_handler*/ ctx[12], false, false, false),
					listen_dev(thead, "SMUI:data-table:cell:mount", /*handleCellMount*/ ctx[4], false, false, false),
					listen_dev(thead, "SMUI:data-table:cell:unmount", /*handleCellUnmount*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, null, null);
				}
			}

			set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(thead);
			if (default_slot) default_slot.d(detaching);
			/*thead_binding*/ ctx[10](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Head", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let element;
	let checkbox;
	let cells = [];
	const cellAccessorMap = new WeakMap();
	setContext("SMUI:data-table:row:header", true);

	onMount(() => {
		const accessor = {
			get cells() {
				return cells;
			},
			get orderedCells() {
				return getOrderedCells();
			},
			get checkbox() {
				return checkbox;
			}
		};

		dispatch(getElement(), "SMUI:data-table:header:mount", accessor);

		return () => {
			dispatch(getElement(), "SMUI:data-table:header:unmount");
		};
	});

	function handleCellMount(event) {
		cells.push(event.detail);
		cellAccessorMap.set(event.detail.element, event.detail);
		event.stopPropagation();
	}

	function handleCellUnmount(event) {
		const idx = cells.indexOf(event.detail);

		if (idx !== -1) {
			cells.splice(idx, 1);
			cells = cells;
		}

		cellAccessorMap.delete(event.detail.element);
		event.stopPropagation();
	}

	function getOrderedCells() {
		return [...getElement().querySelectorAll(".mdc-data-table__header-cell")].map(element => cellAccessorMap.get(element)).filter(accessor => accessor && accessor._smui_data_table_header_cell_accessor);
	}

	function getElement() {
		return element;
	}

	function thead_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	const SMUI_checkbox_mount_handler = event => $$invalidate(2, checkbox = event.detail);
	const SMUI_checkbox_unmount_handler = () => $$invalidate(2, checkbox = undefined);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		useActions,
		dispatch,
		forwardEvents,
		use,
		element,
		checkbox,
		cells,
		cellAccessorMap,
		handleCellMount,
		handleCellUnmount,
		getOrderedCells,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
		if ("checkbox" in $$props) $$invalidate(2, checkbox = $$new_props.checkbox);
		if ("cells" in $$props) cells = $$new_props.cells;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		checkbox,
		forwardEvents,
		handleCellMount,
		handleCellUnmount,
		$$restProps,
		getElement,
		$$scope,
		slots,
		thead_binding,
		SMUI_checkbox_mount_handler,
		SMUI_checkbox_unmount_handler
	];
}

class Head extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { use: 0, getElement: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Head",
			options,
			id: create_fragment$5.name
		});
	}

	get use() {
		throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[7];
	}

	set getElement(value) {
		throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Body.svelte generated by Svelte v3.38.3 */

const file$3 = "node_modules\\@smui\\data-table\\Body.svelte";

function create_fragment$4(ctx) {
	let tbody;
	let tbody_class_value;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let tbody_levels = [
		{
			class: tbody_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-data-table__content": true
			})
		},
		/*$$restProps*/ ctx[6]
	];

	let tbody_data = {};

	for (let i = 0; i < tbody_levels.length; i += 1) {
		tbody_data = assign(tbody_data, tbody_levels[i]);
	}

	const block = {
		c: function create() {
			tbody = element("tbody");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			tbody = claim_element(nodes, "TBODY", { class: true });
			var tbody_nodes = children(tbody);
			if (default_slot) default_slot.l(tbody_nodes);
			tbody_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(tbody, tbody_data);
			add_location(tbody, file$3, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tbody, anchor);

			if (default_slot) {
				default_slot.m(tbody, null);
			}

			/*tbody_binding*/ ctx[10](tbody);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, tbody, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[3].call(null, tbody)),
					listen_dev(tbody, "SMUI:data-table:row:mount", /*handleRowMount*/ ctx[4], false, false, false),
					listen_dev(tbody, "SMUI:data-table:row:unmount", /*handleRowUnmount*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, null, null);
				}
			}

			set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
				(!current || dirty & /*className*/ 2 && tbody_class_value !== (tbody_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-data-table__content": true
				}))) && { class: tbody_class_value },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tbody);
			if (default_slot) default_slot.d(detaching);
			/*tbody_binding*/ ctx[10](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Body", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let rows = [];
	const rowAccessorMap = new WeakMap();
	setContext("SMUI:data-table:row:header", false);

	onMount(() => {
		const accessor = {
			get rows() {
				return rows;
			},
			get orderedRows() {
				return getOrderedRows();
			}
		};

		dispatch(getElement(), "SMUI:data-table:body:mount", accessor);

		return () => {
			dispatch(getElement(), "SMUI:data-table:body:unmount");
		};
	});

	function handleRowMount(event) {
		rows.push(event.detail);
		rowAccessorMap.set(event.detail.element, event.detail);
		event.stopPropagation();
	}

	function handleRowUnmount(event) {
		const idx = rows.indexOf(event.detail);

		if (idx !== -1) {
			rows.splice(idx, 1);
			rows = rows;
		}

		rowAccessorMap.delete(event.detail.element);
		event.stopPropagation();
	}

	function getOrderedRows() {
		return [...getElement().querySelectorAll(".mdc-data-table__row")].map(element => rowAccessorMap.get(element)).filter(accessor => accessor && accessor._smui_data_table_row_accessor);
	}

	function getElement() {
		return element;
	}

	function tbody_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		dispatch,
		forwardEvents,
		use,
		className,
		element,
		rows,
		rowAccessorMap,
		handleRowMount,
		handleRowUnmount,
		getOrderedRows,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
		if ("rows" in $$props) rows = $$new_props.rows;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		element,
		forwardEvents,
		handleRowMount,
		handleRowUnmount,
		$$restProps,
		getElement,
		$$scope,
		slots,
		tbody_binding
	];
}

class Body extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { use: 0, class: 1, getElement: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Body",
			options,
			id: create_fragment$4.name
		});
	}

	get use() {
		throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[7];
	}

	set getElement(value) {
		throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Row.svelte generated by Svelte v3.38.3 */

const file$2 = "node_modules\\@smui\\data-table\\Row.svelte";

function create_fragment$3(ctx) {
	let tr;
	let tr_class_value;
	let tr_aria_selected_value;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	let tr_levels = [
		{
			class: tr_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-data-table__header-row": /*header*/ ctx[7],
				"mdc-data-table__row": !/*header*/ ctx[7],
				"mdc-data-table__row--selected": !/*header*/ ctx[7] && /*checkbox*/ ctx[3] && /*checkbox*/ ctx[3].checked,
				.../*internalClasses*/ ctx[4]
			})
		},
		{
			"aria-selected": tr_aria_selected_value = /*checkbox*/ ctx[3]
			? /*checkbox*/ ctx[3].checked ? "true" : "false"
			: null
		},
		/*internalAttrs*/ ctx[5],
		/*$$restProps*/ ctx[9]
	];

	let tr_data = {};

	for (let i = 0; i < tr_levels.length; i += 1) {
		tr_data = assign(tr_data, tr_levels[i]);
	}

	const block = {
		c: function create() {
			tr = element("tr");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", { class: true, "aria-selected": true });
			var tr_nodes = children(tr);
			if (default_slot) default_slot.l(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(tr, tr_data);
			add_location(tr, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			if (default_slot) {
				default_slot.m(tr, null);
			}

			/*tr_binding*/ ctx[14](tr);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, tr, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[6].call(null, tr)),
					listen_dev(tr, "click", /*click_handler*/ ctx[15], false, false, false),
					listen_dev(tr, "SMUI:checkbox:mount", /*SMUI_checkbox_mount_handler*/ ctx[16], false, false, false),
					listen_dev(tr, "SMUI:checkbox:unmount", /*SMUI_checkbox_unmount_handler*/ ctx[17], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], !current ? -1 : dirty, null, null);
				}
			}

			set_attributes(tr, tr_data = get_spread_update(tr_levels, [
				(!current || dirty & /*className, checkbox, internalClasses*/ 26 && tr_class_value !== (tr_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-data-table__header-row": /*header*/ ctx[7],
					"mdc-data-table__row": !/*header*/ ctx[7],
					"mdc-data-table__row--selected": !/*header*/ ctx[7] && /*checkbox*/ ctx[3] && /*checkbox*/ ctx[3].checked,
					.../*internalClasses*/ ctx[4]
				}))) && { class: tr_class_value },
				(!current || dirty & /*checkbox*/ 8 && tr_aria_selected_value !== (tr_aria_selected_value = /*checkbox*/ ctx[3]
				? /*checkbox*/ ctx[3].checked ? "true" : "false"
				: null)) && { "aria-selected": tr_aria_selected_value },
				dirty & /*internalAttrs*/ 32 && /*internalAttrs*/ ctx[5],
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if (default_slot) default_slot.d(detaching);
			/*tr_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let counter$1 = 0;

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","rowId","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Row", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { rowId = "SMUI-data-table-row-" + counter$1++ } = $$props;
	let element;
	let checkbox;
	let internalClasses = {};
	let internalAttrs = {};
	let header = getContext("SMUI:data-table:row:header");

	onMount(() => {
		const accessor = {
			_smui_data_table_row_accessor: !header,
			get element() {
				return getElement();
			},
			get checkbox() {
				return checkbox;
			},
			get rowId() {
				return rowId;
			},
			get selected() {
				return checkbox && checkbox.checked;
			},
			addClass,
			removeClass,
			getAttr,
			addAttr
		};

		dispatch(getElement(), "SMUI:data-table:row:mount", accessor);

		return () => {
			dispatch(getElement(), "SMUI:data-table:row:unmount");
		};
	});

	function addClass(className) {
		if (!internalClasses[className]) {
			$$invalidate(4, internalClasses[className] = true, internalClasses);
		}
	}

	function removeClass(className) {
		if (!(className in internalClasses) || internalClasses[className]) {
			$$invalidate(4, internalClasses[className] = false, internalClasses);
		}
	}

	function getAttr(name) {
		return name in internalAttrs
		? internalAttrs[name]
		: getElement().getAttribute(name);
	}

	function addAttr(name, value) {
		if (internalAttrs[name] !== value) {
			$$invalidate(5, internalAttrs[name] = value, internalAttrs);
		}
	}

	function notifyHeaderClick(event) {
		dispatch(getElement(), "SMUI:data-table:header:click", event);
	}

	function getElement() {
		return element;
	}

	function tr_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	const click_handler = event => header && notifyHeaderClick(event);
	const SMUI_checkbox_mount_handler = event => $$invalidate(3, checkbox = event.detail);
	const SMUI_checkbox_unmount_handler = () => $$invalidate(3, checkbox = undefined);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("rowId" in $$new_props) $$invalidate(10, rowId = $$new_props.rowId);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		counter: counter$1,
		onMount,
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		dispatch,
		forwardEvents,
		use,
		className,
		rowId,
		element,
		checkbox,
		internalClasses,
		internalAttrs,
		header,
		addClass,
		removeClass,
		getAttr,
		addAttr,
		notifyHeaderClick,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("rowId" in $$props) $$invalidate(10, rowId = $$new_props.rowId);
		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
		if ("checkbox" in $$props) $$invalidate(3, checkbox = $$new_props.checkbox);
		if ("internalClasses" in $$props) $$invalidate(4, internalClasses = $$new_props.internalClasses);
		if ("internalAttrs" in $$props) $$invalidate(5, internalAttrs = $$new_props.internalAttrs);
		if ("header" in $$props) $$invalidate(7, header = $$new_props.header);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		element,
		checkbox,
		internalClasses,
		internalAttrs,
		forwardEvents,
		header,
		notifyHeaderClick,
		$$restProps,
		rowId,
		getElement,
		$$scope,
		slots,
		tr_binding,
		click_handler,
		SMUI_checkbox_mount_handler,
		SMUI_checkbox_unmount_handler
	];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			use: 0,
			class: 1,
			rowId: 10,
			getElement: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$3.name
		});
	}

	get use() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rowId() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rowId(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[11];
	}

	set getElement(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@smui\data-table\Cell.svelte generated by Svelte v3.38.3 */

const file$1 = "node_modules\\@smui\\data-table\\Cell.svelte";

// (39:0) {:else}
function create_else_block_1(ctx) {
	let td;
	let td_class_value;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

	let td_levels = [
		{
			class: td_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-data-table__cell": true,
				"mdc-data-table__cell--numeric": /*numeric*/ ctx[2],
				"mdc-data-table__cell--checkbox": /*checkbox*/ ctx[3],
				.../*internalClasses*/ ctx[7]
			})
		},
		/*internalAttrs*/ ctx[8],
		/*$$restProps*/ ctx[19]
	];

	let td_data = {};

	for (let i = 0; i < td_levels.length; i += 1) {
		td_data = assign(td_data, td_levels[i]);
	}

	const block = {
		c: function create() {
			td = element("td");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true });
			var td_nodes = children(td);
			if (default_slot) default_slot.l(td_nodes);
			td_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(td, td_data);
			add_location(td, file$1, 39, 2, 1200);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);

			if (default_slot) {
				default_slot.m(td, null);
			}

			/*td_binding*/ ctx[25](td);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, td, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[11].call(null, td)),
					listen_dev(td, "change", /*change_handler_1*/ ctx[26], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], !current ? -1 : dirty, null, null);
				}
			}

			set_attributes(td, td_data = get_spread_update(td_levels, [
				(!current || dirty & /*className, numeric, checkbox, internalClasses*/ 142 && td_class_value !== (td_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-data-table__cell": true,
					"mdc-data-table__cell--numeric": /*numeric*/ ctx[2],
					"mdc-data-table__cell--checkbox": /*checkbox*/ ctx[3],
					.../*internalClasses*/ ctx[7]
				}))) && { class: td_class_value },
				dirty & /*internalAttrs*/ 256 && /*internalAttrs*/ ctx[8],
				dirty & /*$$restProps*/ 524288 && /*$$restProps*/ ctx[19]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			if (default_slot) default_slot.d(detaching);
			/*td_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(39:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if header}
function create_if_block$1(ctx) {
	let th;
	let current_block_type_index;
	let if_block;
	let th_class_value;
	let th_aria_sort_value;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*sortable*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let th_levels = [
		{
			class: th_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-data-table__header-cell": true,
				"mdc-data-table__header-cell--numeric": /*numeric*/ ctx[2],
				"mdc-data-table__header-cell--checkbox": /*checkbox*/ ctx[3],
				"mdc-data-table__header-cell--with-sort": /*sortable*/ ctx[5],
				"mdc-data-table__header-cell--sorted": /*sortable*/ ctx[5] && /*$sort*/ ctx[9] === /*columnId*/ ctx[4],
				.../*internalClasses*/ ctx[7]
			})
		},
		{ role: "columnheader" },
		{ scope: "col" },
		{ "data-column-id": /*columnId*/ ctx[4] },
		{
			"aria-sort": th_aria_sort_value = /*sortable*/ ctx[5]
			? /*$sort*/ ctx[9] === /*columnId*/ ctx[4]
				? /*$sortDirection*/ ctx[10]
				: "none"
			: null
		},
		/*internalAttrs*/ ctx[8],
		/*$$restProps*/ ctx[19]
	];

	let th_data = {};

	for (let i = 0; i < th_levels.length; i += 1) {
		th_data = assign(th_data, th_levels[i]);
	}

	const block = {
		c: function create() {
			th = element("th");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			th = claim_element(nodes, "TH", {
				class: true,
				role: true,
				scope: true,
				"data-column-id": true,
				"aria-sort": true
			});

			var th_nodes = children(th);
			if_block.l(th_nodes);
			th_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(th, th_data);
			add_location(th, file$1, 1, 2, 15);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			if_blocks[current_block_type_index].m(th, null);
			/*th_binding*/ ctx[23](th);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, th, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[11].call(null, th)),
					listen_dev(th, "change", /*change_handler*/ ctx[24], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(th, null);
			}

			set_attributes(th, th_data = get_spread_update(th_levels, [
				(!current || dirty & /*className, numeric, checkbox, sortable, $sort, columnId, internalClasses*/ 702 && th_class_value !== (th_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-data-table__header-cell": true,
					"mdc-data-table__header-cell--numeric": /*numeric*/ ctx[2],
					"mdc-data-table__header-cell--checkbox": /*checkbox*/ ctx[3],
					"mdc-data-table__header-cell--with-sort": /*sortable*/ ctx[5],
					"mdc-data-table__header-cell--sorted": /*sortable*/ ctx[5] && /*$sort*/ ctx[9] === /*columnId*/ ctx[4],
					.../*internalClasses*/ ctx[7]
				}))) && { class: th_class_value },
				{ role: "columnheader" },
				{ scope: "col" },
				(!current || dirty & /*columnId*/ 16) && { "data-column-id": /*columnId*/ ctx[4] },
				(!current || dirty & /*sortable, $sort, columnId, $sortDirection*/ 1584 && th_aria_sort_value !== (th_aria_sort_value = /*sortable*/ ctx[5]
				? /*$sort*/ ctx[9] === /*columnId*/ ctx[4]
					? /*$sortDirection*/ ctx[10]
					: "none"
				: null)) && { "aria-sort": th_aria_sort_value },
				dirty & /*internalAttrs*/ 256 && /*internalAttrs*/ ctx[8],
				dirty & /*$$restProps*/ 524288 && /*$$restProps*/ ctx[19]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			if_blocks[current_block_type_index].d();
			/*th_binding*/ ctx[23](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(1:0) {#if header}",
		ctx
	});

	return block;
}

// (37:4) {:else}
function create_else_block$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], !current ? -1 : dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(37:4) {:else}",
		ctx
	});

	return block;
}

// (22:5) {#if sortable}
function create_if_block_1(ctx) {
	let div1;
	let t0;
	let div0;

	let t1_value = (/*$sort*/ ctx[9] === /*columnId*/ ctx[4]
	? /*$sortDirection*/ ctx[10] === "ascending"
		? /*sortAscendingAriaLabel*/ ctx[15]
		: /*sortDescendingAriaLabel*/ ctx[16]
	: "") + "";

	let t1;
	let div0_id_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

	const block = {
		c: function create() {
			div1 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			div0 = element("div");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);

			div0 = claim_element(div1_nodes, "DIV", {
				class: true,
				"aria-hidden": true,
				id: true
			});

			var div0_nodes = children(div0);
			t1 = claim_text(div0_nodes, t1_value);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "mdc-data-table__sort-status-label");
			attr_dev(div0, "aria-hidden", "true");
			attr_dev(div0, "id", div0_id_value = "" + (/*columnId*/ ctx[4] + "-status-label"));
			add_location(div0, file$1, 24, 8, 822);
			attr_dev(div1, "class", "mdc-data-table__header-cell-wrapper");
			add_location(div1, file$1, 22, 6, 747);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], !current ? -1 : dirty, null, null);
				}
			}

			if ((!current || dirty & /*$sort, columnId, $sortDirection*/ 1552) && t1_value !== (t1_value = (/*$sort*/ ctx[9] === /*columnId*/ ctx[4]
			? /*$sortDirection*/ ctx[10] === "ascending"
				? /*sortAscendingAriaLabel*/ ctx[15]
				: /*sortDescendingAriaLabel*/ ctx[16]
			: "") + "")) set_data_dev(t1, t1_value);

			if (!current || dirty & /*columnId*/ 16 && div0_id_value !== (div0_id_value = "" + (/*columnId*/ ctx[4] + "-status-label"))) {
				attr_dev(div0, "id", div0_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(22:5) {#if sortable}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*header*/ ctx[12]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let counter = 0;

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","numeric","checkbox","columnId","sortable","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $sort;
	let $sortDirection;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Cell", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let header = getContext("SMUI:data-table:row:header");
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { numeric = false } = $$props;
	let { checkbox = false } = $$props;
	let { columnId = header ? "SMUI-data-table-column-" + counter++ : null } = $$props;
	let { sortable = getContext("SMUI:data-table:sortable") } = $$props;
	let element;
	let internalClasses = {};
	let internalAttrs = {};
	let sort = getContext("SMUI:data-table:sort");
	validate_store(sort, "sort");
	component_subscribe($$self, sort, value => $$invalidate(9, $sort = value));
	let sortDirection = getContext("SMUI:data-table:sortDirection");
	validate_store(sortDirection, "sortDirection");
	component_subscribe($$self, sortDirection, value => $$invalidate(10, $sortDirection = value));
	let sortAscendingAriaLabel = getContext("SMUI:data-table:sortAscendingAriaLabel");
	let sortDescendingAriaLabel = getContext("SMUI:data-table:sortDescendingAriaLabel");

	if (sortable) {
		setContext("SMUI:label:context", "data-table:sortable-header-cell");
		setContext("SMUI:icon-button:context", "data-table:sortable-header-cell");
		setContext("SMUI:icon-button:aria-describedby", columnId + "-status-label");
	}

	onMount(() => {
		const accessor = {
			_smui_data_table_header_cell_accessor: header,
			get element() {
				return getElement();
			},
			get columnId() {
				return columnId;
			},
			addClass,
			removeClass,
			getAttr,
			addAttr
		};

		dispatch(getElement(), "SMUI:data-table:cell:mount", accessor);

		return () => {
			dispatch(getElement(), "SMUI:data-table:cell:unmount");
		};
	});

	function addClass(className) {
		if (!internalClasses[className]) {
			$$invalidate(7, internalClasses[className] = true, internalClasses);
		}
	}

	function removeClass(className) {
		if (!(className in internalClasses) || internalClasses[className]) {
			$$invalidate(7, internalClasses[className] = false, internalClasses);
		}
	}

	function getAttr(name) {
		return name in internalAttrs
		? internalAttrs[name]
		: getElement().getAttribute(name);
	}

	function addAttr(name, value) {
		if (internalAttrs[name] !== value) {
			$$invalidate(8, internalAttrs[name] = value, internalAttrs);
		}
	}

	function notifyHeaderChange(event) {
		dispatch(getElement(), "SMUI:data-table:header:checkbox:change", event);
	}

	function notifyBodyChange(event) {
		dispatch(getElement(), "SMUI:data-table:body:checkbox:change", event);
	}

	function getElement() {
		return element;
	}

	function th_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(6, element);
		});
	}

	const change_handler = event => checkbox && notifyHeaderChange(event);

	function td_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(6, element);
		});
	}

	const change_handler_1 = event => checkbox && notifyBodyChange(event);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("numeric" in $$new_props) $$invalidate(2, numeric = $$new_props.numeric);
		if ("checkbox" in $$new_props) $$invalidate(3, checkbox = $$new_props.checkbox);
		if ("columnId" in $$new_props) $$invalidate(4, columnId = $$new_props.columnId);
		if ("sortable" in $$new_props) $$invalidate(5, sortable = $$new_props.sortable);
		if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		counter,
		onMount,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		dispatch,
		forwardEvents,
		header,
		use,
		className,
		numeric,
		checkbox,
		columnId,
		sortable,
		element,
		internalClasses,
		internalAttrs,
		sort,
		sortDirection,
		sortAscendingAriaLabel,
		sortDescendingAriaLabel,
		addClass,
		removeClass,
		getAttr,
		addAttr,
		notifyHeaderChange,
		notifyBodyChange,
		getElement,
		$sort,
		$sortDirection
	});

	$$self.$inject_state = $$new_props => {
		if ("header" in $$props) $$invalidate(12, header = $$new_props.header);
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("numeric" in $$props) $$invalidate(2, numeric = $$new_props.numeric);
		if ("checkbox" in $$props) $$invalidate(3, checkbox = $$new_props.checkbox);
		if ("columnId" in $$props) $$invalidate(4, columnId = $$new_props.columnId);
		if ("sortable" in $$props) $$invalidate(5, sortable = $$new_props.sortable);
		if ("element" in $$props) $$invalidate(6, element = $$new_props.element);
		if ("internalClasses" in $$props) $$invalidate(7, internalClasses = $$new_props.internalClasses);
		if ("internalAttrs" in $$props) $$invalidate(8, internalAttrs = $$new_props.internalAttrs);
		if ("sort" in $$props) $$invalidate(13, sort = $$new_props.sort);
		if ("sortDirection" in $$props) $$invalidate(14, sortDirection = $$new_props.sortDirection);
		if ("sortAscendingAriaLabel" in $$props) $$invalidate(15, sortAscendingAriaLabel = $$new_props.sortAscendingAriaLabel);
		if ("sortDescendingAriaLabel" in $$props) $$invalidate(16, sortDescendingAriaLabel = $$new_props.sortDescendingAriaLabel);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		numeric,
		checkbox,
		columnId,
		sortable,
		element,
		internalClasses,
		internalAttrs,
		$sort,
		$sortDirection,
		forwardEvents,
		header,
		sort,
		sortDirection,
		sortAscendingAriaLabel,
		sortDescendingAriaLabel,
		notifyHeaderChange,
		notifyBodyChange,
		$$restProps,
		getElement,
		$$scope,
		slots,
		th_binding,
		change_handler,
		td_binding,
		change_handler_1
	];
}

class Cell extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			use: 0,
			class: 1,
			numeric: 2,
			checkbox: 3,
			columnId: 4,
			sortable: 5,
			getElement: 20
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cell",
			options,
			id: create_fragment$2.name
		});
	}

	get use() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get numeric() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set numeric(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checkbox() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checkbox(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get columnId() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set columnId(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[20];
	}

	set getElement(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\User\UserTable.svelte generated by Svelte v3.38.3 */

const { console: console_1 } = globals;

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (45:16) <IconButton class="material-icons">
function create_default_slot_30(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_30.name,
		type: "slot",
		source: "(45:16) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (46:16) <Label>
function create_default_slot_29(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("ID");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "ID");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_29.name,
		type: "slot",
		source: "(46:16) <Label>",
		ctx
	});

	return block;
}

// (44:12) <Cell numeric columnId="id">
function create_default_slot_28(ctx) {
	let iconbutton;
	let t;
	let label;
	let current;

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_30] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_29] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconbutton.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbutton.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbutton, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbutton, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_28.name,
		type: "slot",
		source: "(44:12) <Cell numeric columnId=\\\"id\\\">",
		ctx
	});

	return block;
}

// (49:16) <Label>
function create_default_slot_27(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Name");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Name");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_27.name,
		type: "slot",
		source: "(49:16) <Label>",
		ctx
	});

	return block;
}

// (50:16) <IconButton class="material-icons">
function create_default_slot_26(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_26.name,
		type: "slot",
		source: "(50:16) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (48:12) <Cell columnId="name" style="width: 100%;">
function create_default_slot_25(ctx) {
	let label;
	let t;
	let iconbutton;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_27] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_26] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(iconbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_25.name,
		type: "slot",
		source: "(48:12) <Cell columnId=\\\"name\\\" style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

// (53:16) <Label>
function create_default_slot_24(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Username");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Username");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_24.name,
		type: "slot",
		source: "(53:16) <Label>",
		ctx
	});

	return block;
}

// (54:16) <IconButton class="material-icons">
function create_default_slot_23(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_23.name,
		type: "slot",
		source: "(54:16) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (52:12) <Cell columnId="username">
function create_default_slot_22(ctx) {
	let label;
	let t;
	let iconbutton;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_24] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_23] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(iconbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(52:12) <Cell columnId=\\\"username\\\">",
		ctx
	});

	return block;
}

// (57:16) <Label>
function create_default_slot_21(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Email");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Email");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(57:16) <Label>",
		ctx
	});

	return block;
}

// (58:16) <IconButton class="material-icons">
function create_default_slot_20(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(58:16) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (56:12) <Cell columnId="email" l>
function create_default_slot_19(ctx) {
	let label;
	let t;
	let iconbutton;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_21] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(iconbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(56:12) <Cell columnId=\\\"email\\\" l>",
		ctx
	});

	return block;
}

// (60:12) <Cell sortable={false}>
function create_default_slot_18(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Website");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Website");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(60:12) <Cell sortable={false}>",
		ctx
	});

	return block;
}

// (61:12) <Cell sortable={false}>
function create_default_slot_17(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Actions");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Actions");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(61:12) <Cell sortable={false}>",
		ctx
	});

	return block;
}

// (43:8) <Row>
function create_default_slot_16(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let t4;
	let cell5;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				columnId: "id",
				$$slots: { default: [create_default_slot_28] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				columnId: "name",
				style: "width: 100%;",
				$$slots: { default: [create_default_slot_25] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				columnId: "username",
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				columnId: "email",
				l: true,
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				sortable: false,
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell5 = new Cell({
			props: {
				sortable: false,
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
			t4 = space();
			create_component(cell5.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(cell4.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(cell5.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(cell5, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
			const cell5_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				cell5_changes.$$scope = { dirty, ctx };
			}

			cell5.$set(cell5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			transition_in(cell5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			transition_out(cell5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(cell5, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(43:8) <Row>",
		ctx
	});

	return block;
}

// (42:4) <Head>
function create_default_slot_15(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(42:4) <Head>",
		ctx
	});

	return block;
}

// (67:16) <Cell numeric>
function create_default_slot_14(ctx) {
	let t_value = /*item*/ ctx[7].id + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchedUsers*/ 1 && t_value !== (t_value = /*item*/ ctx[7].id + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(67:16) <Cell numeric>",
		ctx
	});

	return block;
}

// (68:16) <Cell>
function create_default_slot_13(ctx) {
	let t_value = /*item*/ ctx[7].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchedUsers*/ 1 && t_value !== (t_value = /*item*/ ctx[7].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(68:16) <Cell>",
		ctx
	});

	return block;
}

// (69:16) <Cell>
function create_default_slot_12(ctx) {
	let t_value = /*item*/ ctx[7].username + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchedUsers*/ 1 && t_value !== (t_value = /*item*/ ctx[7].username + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(69:16) <Cell>",
		ctx
	});

	return block;
}

// (70:16) <Cell>
function create_default_slot_11(ctx) {
	let t_value = /*item*/ ctx[7].email + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchedUsers*/ 1 && t_value !== (t_value = /*item*/ ctx[7].email + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(70:16) <Cell>",
		ctx
	});

	return block;
}

// (71:16) <Cell>
function create_default_slot_10(ctx) {
	let t_value = /*item*/ ctx[7].website + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchedUsers*/ 1 && t_value !== (t_value = /*item*/ ctx[7].website + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(71:16) <Cell>",
		ctx
	});

	return block;
}

// (74:24) <Icon class="material-icons">
function create_default_slot_9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("edit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(74:24) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (78:24) <LabelButton>
function create_default_slot_8(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(78:24) <LabelButton>",
		ctx
	});

	return block;
}

// (73:20) <Button href="/user/form/{item.id}" variant="raised">
function create_default_slot_7(ctx) {
	let icon;
	let t;
	let labelbutton;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	labelbutton = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			create_component(labelbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(labelbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(labelbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const labelbutton_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				labelbutton_changes.$$scope = { dirty, ctx };
			}

			labelbutton.$set(labelbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(labelbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(labelbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			destroy_component(labelbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(73:20) <Button href=\\\"/user/form/{item.id}\\\" variant=\\\"raised\\\">",
		ctx
	});

	return block;
}

// (82:24) <Icon class="material-icons">
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("remove_circle_outline");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "remove_circle_outline");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(82:24) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (86:24) <LabelButton>
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(86:24) <LabelButton>",
		ctx
	});

	return block;
}

// (81:20) <Button on:click={() => console.log('clicked!')} variant="outlined">
function create_default_slot_4(ctx) {
	let icon;
	let t;
	let labelbutton;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	labelbutton = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			create_component(labelbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(labelbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(labelbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const labelbutton_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				labelbutton_changes.$$scope = { dirty, ctx };
			}

			labelbutton.$set(labelbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(labelbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(labelbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			destroy_component(labelbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(81:20) <Button on:click={() => console.log('clicked!')} variant=\\\"outlined\\\">",
		ctx
	});

	return block;
}

// (72:16) <Cell>
function create_default_slot_3(ctx) {
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button_1({
			props: {
				href: "/user/form/" + /*item*/ ctx[7].id,
				variant: "raised",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1 = new Button_1({
			props: {
				variant: "outlined",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button0.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(button1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};
			if (dirty & /*fetchedUsers*/ 1) button0_changes.href = "/user/form/" + /*item*/ ctx[7].id;

			if (dirty & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(72:16) <Cell>",
		ctx
	});

	return block;
}

// (66:12) <Row>
function create_default_slot_2(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let t4;
	let cell5;
	let t5;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell5 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
			t4 = space();
			create_component(cell5.$$.fragment);
			t5 = space();
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(cell4.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(cell5.$$.fragment, nodes);
			t5 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(cell5, target, anchor);
			insert_dev(target, t5, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
			const cell5_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				cell5_changes.$$scope = { dirty, ctx };
			}

			cell5.$set(cell5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			transition_in(cell5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			transition_out(cell5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(cell5, detaching);
			if (detaching) detach_dev(t5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(66:12) <Row>",
		ctx
	});

	return block;
}

// (65:8) {#each fetchedUsers as item (item.id)}
function create_each_block(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(row.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(65:8) {#each fetchedUsers as item (item.id)}",
		ctx
	});

	return block;
}

// (64:4) <Body>
function create_default_slot_1$1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*fetchedUsers*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[7].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*console, fetchedUsers*/ 1) {
				each_value = /*fetchedUsers*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(64:4) <Body>",
		ctx
	});

	return block;
}

// (35:0) <DataTable      sortable      bind:sort      bind:sortDirection      on:MDCDataTable:sorted={handleSort}      table$aria-label="User list"      style="width: 100%;">
function create_default_slot$1(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(head.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(body.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(35:0) <DataTable      sortable      bind:sort      bind:sortDirection      on:MDCDataTable:sorted={handleSort}      table$aria-label=\\\"User list\\\"      style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let datatable;
	let updating_sort;
	let updating_sortDirection;
	let current;

	function datatable_sort_binding(value) {
		/*datatable_sort_binding*/ ctx[5](value);
	}

	function datatable_sortDirection_binding(value) {
		/*datatable_sortDirection_binding*/ ctx[6](value);
	}

	let datatable_props = {
		sortable: true,
		"table$aria-label": "User list",
		style: "width: 100%;",
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*sort*/ ctx[1] !== void 0) {
		datatable_props.sort = /*sort*/ ctx[1];
	}

	if (/*sortDirection*/ ctx[2] !== void 0) {
		datatable_props.sortDirection = /*sortDirection*/ ctx[2];
	}

	datatable = new DataTable({ props: datatable_props, $$inline: true });
	binding_callbacks.push(() => bind(datatable, "sort", datatable_sort_binding));
	binding_callbacks.push(() => bind(datatable, "sortDirection", datatable_sortDirection_binding));
	datatable.$on("MDCDataTable:sorted", /*handleSort*/ ctx[3]);

	const block = {
		c: function create() {
			create_component(datatable.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(datatable.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(datatable, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const datatable_changes = {};

			if (dirty & /*$$scope, fetchedUsers*/ 1025) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			if (!updating_sort && dirty & /*sort*/ 2) {
				updating_sort = true;
				datatable_changes.sort = /*sort*/ ctx[1];
				add_flush_callback(() => updating_sort = false);
			}

			if (!updating_sortDirection && dirty & /*sortDirection*/ 4) {
				updating_sortDirection = true;
				datatable_changes.sortDirection = /*sortDirection*/ ctx[2];
				add_flush_callback(() => updating_sortDirection = false);
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(datatable, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UserTable", slots, []);
	let { fetchedUsers } = $$props;
	let sort = "id";
	let sortDirection = "ascending";

	function handleSort() {
		fetchedUsers.sort((a, b) => {
			const [aVal, bVal] = [a[sort], b[sort]][sortDirection === "ascending" ? "slice" : "reverse"]();

			if (typeof aVal === "string") {
				return aVal.localeCompare(bVal);
			}

			return aVal - bVal;
		});

		customUsers.setUsers(fetchedUsers);
	}

	const writable_props = ["fetchedUsers"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<UserTable> was created with unknown prop '${key}'`);
	});

	const click_handler = () => console.log("clicked!");

	function datatable_sort_binding(value) {
		sort = value;
		$$invalidate(1, sort);
	}

	function datatable_sortDirection_binding(value) {
		sortDirection = value;
		$$invalidate(2, sortDirection);
	}

	$$self.$$set = $$props => {
		if ("fetchedUsers" in $$props) $$invalidate(0, fetchedUsers = $$props.fetchedUsers);
	};

	$$self.$capture_state = () => ({
		DataTable,
		Head,
		Body,
		Row,
		Cell,
		Label: CommonLabel,
		IconButton,
		Button: Button_1,
		LabelButton: CommonLabel,
		Icon: CommonIcon,
		users: customUsers,
		fetchedUsers,
		sort,
		sortDirection,
		handleSort
	});

	$$self.$inject_state = $$props => {
		if ("fetchedUsers" in $$props) $$invalidate(0, fetchedUsers = $$props.fetchedUsers);
		if ("sort" in $$props) $$invalidate(1, sort = $$props.sort);
		if ("sortDirection" in $$props) $$invalidate(2, sortDirection = $$props.sortDirection);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		fetchedUsers,
		sort,
		sortDirection,
		handleSort,
		click_handler,
		datatable_sort_binding,
		datatable_sortDirection_binding
	];
}

class UserTable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { fetchedUsers: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserTable",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*fetchedUsers*/ ctx[0] === undefined && !("fetchedUsers" in props)) {
			console_1.warn("<UserTable> was created without expected prop 'fetchedUsers'");
		}
	}

	get fetchedUsers() {
		throw new Error("<UserTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fetchedUsers(value) {
		throw new Error("<UserTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\user\index.svelte generated by Svelte v3.38.3 */
const file = "src\\routes\\user\\index.svelte";

// (33:2) <Label>
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add New User");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Add New User");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(33:2) <Label>",
		ctx
	});

	return block;
}

// (32:1) <Button href="/user/form" variant="raised">
function create_default_slot(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 8) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(32:1) <Button href=\\\"/user/form\\\" variant=\\\"raised\\\">",
		ctx
	});

	return block;
}

// (39:0) {:else}
function create_else_block(ctx) {
	let usertable;
	let current;

	usertable = new UserTable({
			props: { fetchedUsers: /*fetchedUsers*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(usertable.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(usertable.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(usertable, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const usertable_changes = {};
			if (dirty & /*fetchedUsers*/ 1) usertable_changes.fetchedUsers = /*fetchedUsers*/ ctx[0];
			usertable.$set(usertable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(usertable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(usertable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(usertable, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(39:0) {:else}",
		ctx
	});

	return block;
}

// (37:0) {#if isLoading}
function create_if_block(ctx) {
	let loadingspinner;
	let current;
	loadingspinner = new LoadingSpinner({ $$inline: true });

	const block = {
		c: function create() {
			create_component(loadingspinner.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loadingspinner.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loadingspinner, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingspinner, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(37:0) {#if isLoading}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let div;
	let button;
	let t1;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	button = new Button_1({
			props: {
				href: "/user/form",
				variant: "raised",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLoading*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			t0 = space();
			div = element("div");
			create_component(button.$$.fragment);
			t1 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-mc1kyo\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			document.title = "Dashboard";
			attr_dev(div, "class", "flex-end-btn");
			add_location(div, file, 30, 0, 614);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			insert_dev(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			destroy_component(button);
			if (detaching) detach_dev(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("User", slots, []);
	let fetchedUsers;
	let unsubscribe;
	let isLoading = true;

	onMount(() => {
		unsubscribe = customUsers.subscribe(items => {
			$$invalidate(0, fetchedUsers = items);
			$$invalidate(1, isLoading = false);
		});
	});

	onDestroy(() => {
		if (unsubscribe) {
			unsubscribe();
		}
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<User> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		users: customUsers,
		Button: Button_1,
		Label: CommonLabel,
		LoadingSpinner,
		UserTable,
		fetchedUsers,
		unsubscribe,
		isLoading
	});

	$$self.$inject_state = $$props => {
		if ("fetchedUsers" in $$props) $$invalidate(0, fetchedUsers = $$props.fetchedUsers);
		if ("unsubscribe" in $$props) unsubscribe = $$props.unsubscribe;
		if ("isLoading" in $$props) $$invalidate(1, isLoading = $$props.isLoading);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [fetchedUsers, isLoading];
}

class User extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "User",
			options,
			id: create_fragment.name
		});
	}
}

export default User;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNTcyNzNjN2IuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac211aS9jb21tb24vSS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNtdWkvY29tbW9uL1N2Zy5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNtdWkvY29tbW9uL0NvbW1vbkljb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3N0b3JlL3VzZXJzLXN0b3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzbXVpL2J1dHRvbi9CdXR0b24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzbXVpL2NvbW1vbi9Db21tb25MYWJlbC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RhdGEtdGFibGUvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kYXRhLXRhYmxlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNtdWkvZGF0YS10YWJsZS9EYXRhVGFibGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzbXVpL2RhdGEtdGFibGUvSGVhZC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNtdWkvZGF0YS10YWJsZS9Cb2R5LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac211aS9kYXRhLXRhYmxlL1Jvdy5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNtdWkvZGF0YS10YWJsZS9DZWxsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1VzZXIvVXNlclRhYmxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvdXNlci9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPGkgYmluZDp0aGlzPXtlbGVtZW50fSB1c2U6dXNlQWN0aW9ucz17dXNlfSB1c2U6Zm9yd2FyZEV2ZW50cyB7Li4uJCRyZXN0UHJvcHN9XG4gID48c2xvdCAvPjwvaVxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuICBpbXBvcnQgeyBmb3J3YXJkRXZlbnRzQnVpbGRlciwgdXNlQWN0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHN2ZyBiaW5kOnRoaXM9e2VsZW1lbnR9IHVzZTp1c2VBY3Rpb25zPXt1c2V9IHVzZTpmb3J3YXJkRXZlbnRzIHsuLi4kJHJlc3RQcm9wc31cbiAgPjxzbG90IC8+PC9zdmdcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIHVzZUFjdGlvbnMgfSBmcm9tICcuL2ludGVybmFsLmpzJztcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG48L3NjcmlwdD5cbiIsIjxzdmVsdGU6Y29tcG9uZW50XG4gIHRoaXM9e2NvbXBvbmVudH1cbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICB1c2U9e1tmb3J3YXJkRXZlbnRzLCAuLi51c2VdfVxuICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgIFtjbGFzc05hbWVdOiB0cnVlLFxuICAgICdtZGMtYnV0dG9uX19pY29uJzogY29udGV4dCA9PT0gJ2J1dHRvbicsXG4gICAgJ21kYy1mYWJfX2ljb24nOiBjb250ZXh0ID09PSAnZmFiJyxcbiAgICAnbWRjLWljb24tYnV0dG9uX19pY29uJzogY29udGV4dCA9PT0gJ2ljb24tYnV0dG9uJyxcbiAgICAnbWRjLWljb24tYnV0dG9uX19pY29uLS1vbic6IGNvbnRleHQgPT09ICdpY29uLWJ1dHRvbicgJiYgb24sXG4gICAgJ21kYy10YWJfX2ljb24nOiBjb250ZXh0ID09PSAndGFiJyxcbiAgICAnbWRjLWJhbm5lcl9faWNvbic6IGNvbnRleHQgPT09ICdiYW5uZXInLFxuICAgICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9faWNvbic6IGNvbnRleHQgPT09ICdzZWdtZW50ZWQtYnV0dG9uJyxcbiAgfSl9XG4gIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gIHsuLi5jb21wb25lbnQgPT09IFN2ZyA/IHsgZm9jdXNhYmxlOiAnZmFsc2UnLCB0YWJpbmRleDogJy0xJyB9IDoge319XG4gIHsuLi4kJHJlc3RQcm9wc30+PHNsb3QgLz48L3N2ZWx0ZTpjb21wb25lbnRcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7IGZvcndhcmRFdmVudHNCdWlsZGVyLCBjbGFzc01hcCB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuICBpbXBvcnQgSSBmcm9tICcuL0kuc3ZlbHRlJztcbiAgaW1wb3J0IFN2ZyBmcm9tICcuL1N2Zy5zdmVsdGUnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbiAgZXhwb3J0IGxldCBvbiA9IGZhbHNlO1xuXG4gIGxldCBlbGVtZW50O1xuXG4gIGV4cG9ydCBsZXQgY29tcG9uZW50ID0gSTtcblxuICBjb25zdCBjb250ZXh0ID0gZ2V0Q29udGV4dCgnU01VSTppY29uOmNvbnRleHQnKTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50KCk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xyXG5cclxuY29uc3QgdXNlcnMgPSB3cml0YWJsZShbXHJcbiAgICB7XHJcbiAgICAgICAgXCJpZFwiOiAxLFxyXG4gICAgICAgIFwibmFtZVwiOiBcIkxlYW5uZSBHcmFoYW1cIixcclxuICAgICAgICBcInVzZXJuYW1lXCI6IFwiQnJldFwiLFxyXG4gICAgICAgIFwiZW1haWxcIjogXCJTaW5jZXJlQGFwcmlsLmJpelwiLFxyXG4gICAgICAgIFwid2Vic2l0ZVwiOiBcImhpbGRlZ2FyZC5vcmdcIixcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgXCJpZFwiOiAyLFxyXG4gICAgICAgIFwibmFtZVwiOiBcIkVydmluIEhvd2VsbFwiLFxyXG4gICAgICAgIFwidXNlcm5hbWVcIjogXCJBbnRvbmV0dGVcIixcclxuICAgICAgICBcImVtYWlsXCI6IFwiU2hhbm5hQG1lbGlzc2EudHZcIixcclxuICAgICAgICBcIndlYnNpdGVcIjogXCJhbmFzdGFzaWEubmV0XCIsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIFwiaWRcIjogMyxcclxuICAgICAgICBcIm5hbWVcIjogXCJDbGVtZW50aW5lIEJhdWNoXCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIlNhbWFudGhhXCIsXHJcbiAgICAgICAgXCJlbWFpbFwiOiBcIk5hdGhhbkB5ZXNlbmlhLm5ldFwiLFxyXG4gICAgICAgIFwid2Vic2l0ZVwiOiBcInJhbWlyby5pbmZvXCIsXHJcbiAgICB9LFxyXG4gICAgLyoge1xyXG4gICAgICAgIFwiaWRcIjogNCxcclxuICAgICAgICBcIm5hbWVcIjogXCJQYXRyaWNpYSBMZWJzYWNrXCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIkthcmlhbm5lXCIsXHJcbiAgICAgICAgXCJlbWFpbFwiOiBcIkp1bGlhbm5lLk9Db25uZXJAa29yeS5vcmdcIixcclxuICAgICAgICBcImFkZHJlc3NcIjoge1xyXG4gICAgICAgICAgICBcInN0cmVldFwiOiBcIkhvZWdlciBNYWxsXCIsXHJcbiAgICAgICAgICAgIFwic3VpdGVcIjogXCJBcHQuIDY5MlwiLFxyXG4gICAgICAgICAgICBcImNpdHlcIjogXCJTb3V0aCBFbHZpc1wiLFxyXG4gICAgICAgICAgICBcInppcGNvZGVcIjogXCI1MzkxOS00MjU3XCIsXHJcbiAgICAgICAgICAgIFwiZ2VvXCI6IHtcclxuICAgICAgICAgICAgICAgIFwibGF0XCI6IFwiMjkuNDU3MlwiLFxyXG4gICAgICAgICAgICAgICAgXCJsbmdcIjogXCItMTY0LjI5OTBcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBob25lXCI6IFwiNDkzLTE3MC05NjIzIHgxNTZcIixcclxuICAgICAgICBcIndlYnNpdGVcIjogXCJrYWxlLmJpelwiLFxyXG4gICAgICAgIFwiY29tcGFueVwiOiB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlJvYmVsLUNvcmtlcnlcIixcclxuICAgICAgICAgICAgXCJjYXRjaFBocmFzZVwiOiBcIk11bHRpLXRpZXJlZCB6ZXJvIHRvbGVyYW5jZSBwcm9kdWN0aXZpdHlcIixcclxuICAgICAgICAgICAgXCJic1wiOiBcInRyYW5zaXRpb24gY3V0dGluZy1lZGdlIHdlYiBzZXJ2aWNlc1wiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBcImlkXCI6IDUsXHJcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2hlbHNleSBEaWV0cmljaFwiLFxyXG4gICAgICAgIFwidXNlcm5hbWVcIjogXCJLYW1yZW5cIixcclxuICAgICAgICBcImVtYWlsXCI6IFwiTHVjaW9fSGV0dGluZ2VyQGFubmllLmNhXCIsXHJcbiAgICAgICAgXCJhZGRyZXNzXCI6IHtcclxuICAgICAgICAgICAgXCJzdHJlZXRcIjogXCJTa2lsZXMgV2Fsa3NcIixcclxuICAgICAgICAgICAgXCJzdWl0ZVwiOiBcIlN1aXRlIDM1MVwiLFxyXG4gICAgICAgICAgICBcImNpdHlcIjogXCJSb3Njb2V2aWV3XCIsXHJcbiAgICAgICAgICAgIFwiemlwY29kZVwiOiBcIjMzMjYzXCIsXHJcbiAgICAgICAgICAgIFwiZ2VvXCI6IHtcclxuICAgICAgICAgICAgICAgIFwibGF0XCI6IFwiLTMxLjgxMjlcIixcclxuICAgICAgICAgICAgICAgIFwibG5nXCI6IFwiNjIuNTM0MlwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicGhvbmVcIjogXCIoMjU0KTk1NC0xMjg5XCIsXHJcbiAgICAgICAgXCJ3ZWJzaXRlXCI6IFwiZGVtYXJjby5pbmZvXCIsXHJcbiAgICAgICAgXCJjb21wYW55XCI6IHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiS2VlYmxlciBMTENcIixcclxuICAgICAgICAgICAgXCJjYXRjaFBocmFzZVwiOiBcIlVzZXItY2VudHJpYyBmYXVsdC10b2xlcmFudCBzb2x1dGlvblwiLFxyXG4gICAgICAgICAgICBcImJzXCI6IFwicmV2b2x1dGlvbml6ZSBlbmQtdG8tZW5kIHN5c3RlbXNcIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgXCJpZFwiOiA2LFxyXG4gICAgICAgIFwibmFtZVwiOiBcIk1ycy4gRGVubmlzIFNjaHVsaXN0XCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIkxlb3BvbGRvX0NvcmtlcnlcIixcclxuICAgICAgICBcImVtYWlsXCI6IFwiS2FybGV5X0RhY2hAamFzcGVyLmluZm9cIixcclxuICAgICAgICBcImFkZHJlc3NcIjoge1xyXG4gICAgICAgICAgICBcInN0cmVldFwiOiBcIk5vcmJlcnRvIENyb3NzaW5nXCIsXHJcbiAgICAgICAgICAgIFwic3VpdGVcIjogXCJBcHQuIDk1MFwiLFxyXG4gICAgICAgICAgICBcImNpdHlcIjogXCJTb3V0aCBDaHJpc3R5XCIsXHJcbiAgICAgICAgICAgIFwiemlwY29kZVwiOiBcIjIzNTA1LTEzMzdcIixcclxuICAgICAgICAgICAgXCJnZW9cIjoge1xyXG4gICAgICAgICAgICAgICAgXCJsYXRcIjogXCItNzEuNDE5N1wiLFxyXG4gICAgICAgICAgICAgICAgXCJsbmdcIjogXCI3MS43NDc4XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwaG9uZVwiOiBcIjEtNDc3LTkzNS04NDc4IHg2NDMwXCIsXHJcbiAgICAgICAgXCJ3ZWJzaXRlXCI6IFwib2xhLm9yZ1wiLFxyXG4gICAgICAgIFwiY29tcGFueVwiOiB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkNvbnNpZGluZS1Mb2NrbWFuXCIsXHJcbiAgICAgICAgICAgIFwiY2F0Y2hQaHJhc2VcIjogXCJTeW5jaHJvbmlzZWQgYm90dG9tLWxpbmUgaW50ZXJmYWNlXCIsXHJcbiAgICAgICAgICAgIFwiYnNcIjogXCJlLWVuYWJsZSBpbm5vdmF0aXZlIGFwcGxpY2F0aW9uc1wiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBcImlkXCI6IDcsXHJcbiAgICAgICAgXCJuYW1lXCI6IFwiS3VydGlzIFdlaXNzbmF0XCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIkVsd3luLlNraWxlc1wiLFxyXG4gICAgICAgIFwiZW1haWxcIjogXCJUZWxseS5Ib2VnZXJAYmlsbHkuYml6XCIsXHJcbiAgICAgICAgXCJhZGRyZXNzXCI6IHtcclxuICAgICAgICAgICAgXCJzdHJlZXRcIjogXCJSZXggVHJhaWxcIixcclxuICAgICAgICAgICAgXCJzdWl0ZVwiOiBcIlN1aXRlIDI4MFwiLFxyXG4gICAgICAgICAgICBcImNpdHlcIjogXCJIb3dlbW91dGhcIixcclxuICAgICAgICAgICAgXCJ6aXBjb2RlXCI6IFwiNTg4MDQtMTA5OVwiLFxyXG4gICAgICAgICAgICBcImdlb1wiOiB7XHJcbiAgICAgICAgICAgICAgICBcImxhdFwiOiBcIjI0Ljg5MThcIixcclxuICAgICAgICAgICAgICAgIFwibG5nXCI6IFwiMjEuODk4NFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicGhvbmVcIjogXCIyMTAuMDY3LjYxMzJcIixcclxuICAgICAgICBcIndlYnNpdGVcIjogXCJlbHZpcy5pb1wiLFxyXG4gICAgICAgIFwiY29tcGFueVwiOiB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkpvaG5zIEdyb3VwXCIsXHJcbiAgICAgICAgICAgIFwiY2F0Y2hQaHJhc2VcIjogXCJDb25maWd1cmFibGUgbXVsdGltZWRpYSB0YXNrLWZvcmNlXCIsXHJcbiAgICAgICAgICAgIFwiYnNcIjogXCJnZW5lcmF0ZSBlbnRlcnByaXNlIGUtdGFpbGVyc1wiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBcImlkXCI6IDgsXHJcbiAgICAgICAgXCJuYW1lXCI6IFwiTmljaG9sYXMgUnVub2xmc2RvdHRpciBWXCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIk1heGltZV9OaWVub3dcIixcclxuICAgICAgICBcImVtYWlsXCI6IFwiU2hlcndvb2RAcm9zYW1vbmQubWVcIixcclxuICAgICAgICBcImFkZHJlc3NcIjoge1xyXG4gICAgICAgICAgICBcInN0cmVldFwiOiBcIkVsbHN3b3J0aCBTdW1taXRcIixcclxuICAgICAgICAgICAgXCJzdWl0ZVwiOiBcIlN1aXRlIDcyOVwiLFxyXG4gICAgICAgICAgICBcImNpdHlcIjogXCJBbGl5YXZpZXdcIixcclxuICAgICAgICAgICAgXCJ6aXBjb2RlXCI6IFwiNDUxNjlcIixcclxuICAgICAgICAgICAgXCJnZW9cIjoge1xyXG4gICAgICAgICAgICAgICAgXCJsYXRcIjogXCItMTQuMzk5MFwiLFxyXG4gICAgICAgICAgICAgICAgXCJsbmdcIjogXCItMTIwLjc2NzdcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBob25lXCI6IFwiNTg2LjQ5My42OTQzIHgxNDBcIixcclxuICAgICAgICBcIndlYnNpdGVcIjogXCJqYWN5bnRoZS5jb21cIixcclxuICAgICAgICBcImNvbXBhbnlcIjoge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBYmVybmF0aHkgR3JvdXBcIixcclxuICAgICAgICAgICAgXCJjYXRjaFBocmFzZVwiOiBcIkltcGxlbWVudGVkIHNlY29uZGFyeSBjb25jZXB0XCIsXHJcbiAgICAgICAgICAgIFwiYnNcIjogXCJlLWVuYWJsZSBleHRlbnNpYmxlIGUtdGFpbGVyc1wiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBcImlkXCI6IDksXHJcbiAgICAgICAgXCJuYW1lXCI6IFwiR2xlbm5hIFJlaWNoZXJ0XCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIkRlbHBoaW5lXCIsXHJcbiAgICAgICAgXCJlbWFpbFwiOiBcIkNoYWltX01jRGVybW90dEBkYW5hLmlvXCIsXHJcbiAgICAgICAgXCJhZGRyZXNzXCI6IHtcclxuICAgICAgICAgICAgXCJzdHJlZXRcIjogXCJEYXluYSBQYXJrXCIsXHJcbiAgICAgICAgICAgIFwic3VpdGVcIjogXCJTdWl0ZSA0NDlcIixcclxuICAgICAgICAgICAgXCJjaXR5XCI6IFwiQmFydGhvbG9tZWJ1cnlcIixcclxuICAgICAgICAgICAgXCJ6aXBjb2RlXCI6IFwiNzY0OTUtMzEwOVwiLFxyXG4gICAgICAgICAgICBcImdlb1wiOiB7XHJcbiAgICAgICAgICAgICAgICBcImxhdFwiOiBcIjI0LjY0NjNcIixcclxuICAgICAgICAgICAgICAgIFwibG5nXCI6IFwiLTE2OC44ODg5XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwaG9uZVwiOiBcIig3NzUpOTc2LTY3OTQgeDQxMjA2XCIsXHJcbiAgICAgICAgXCJ3ZWJzaXRlXCI6IFwiY29ucmFkLmNvbVwiLFxyXG4gICAgICAgIFwiY29tcGFueVwiOiB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIllvc3QgYW5kIFNvbnNcIixcclxuICAgICAgICAgICAgXCJjYXRjaFBocmFzZVwiOiBcIlN3aXRjaGFibGUgY29udGV4dHVhbGx5LWJhc2VkIHByb2plY3RcIixcclxuICAgICAgICAgICAgXCJic1wiOiBcImFnZ3JlZ2F0ZSByZWFsLXRpbWUgdGVjaG5vbG9naWVzXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIFwiaWRcIjogMTAsXHJcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2xlbWVudGluYSBEdUJ1cXVlXCIsXHJcbiAgICAgICAgXCJ1c2VybmFtZVwiOiBcIk1vcmlhaC5TdGFudG9uXCIsXHJcbiAgICAgICAgXCJlbWFpbFwiOiBcIlJleS5QYWRiZXJnQGthcmluYS5iaXpcIixcclxuICAgICAgICBcImFkZHJlc3NcIjoge1xyXG4gICAgICAgICAgICBcInN0cmVldFwiOiBcIkthdHRpZSBUdXJucGlrZVwiLFxyXG4gICAgICAgICAgICBcInN1aXRlXCI6IFwiU3VpdGUgMTk4XCIsXHJcbiAgICAgICAgICAgIFwiY2l0eVwiOiBcIkxlYnNhY2tidXJ5XCIsXHJcbiAgICAgICAgICAgIFwiemlwY29kZVwiOiBcIjMxNDI4LTIyNjFcIixcclxuICAgICAgICAgICAgXCJnZW9cIjoge1xyXG4gICAgICAgICAgICAgICAgXCJsYXRcIjogXCItMzguMjM4NlwiLFxyXG4gICAgICAgICAgICAgICAgXCJsbmdcIjogXCI1Ny4yMjMyXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwaG9uZVwiOiBcIjAyNC02NDgtMzgwNFwiLFxyXG4gICAgICAgIFwid2Vic2l0ZVwiOiBcImFtYnJvc2UubmV0XCIsXHJcbiAgICAgICAgXCJjb21wYW55XCI6IHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiSG9lZ2VyIExMQ1wiLFxyXG4gICAgICAgICAgICBcImNhdGNoUGhyYXNlXCI6IFwiQ2VudHJhbGl6ZWQgZW1wb3dlcmluZyB0YXNrLWZvcmNlXCIsXHJcbiAgICAgICAgICAgIFwiYnNcIjogXCJ0YXJnZXQgZW5kLXRvLWVuZCBtb2RlbHNcIlxyXG4gICAgICAgIH1cclxuICAgIH0gKi9cclxuXSk7XHJcblxyXG5jb25zdCBjdXN0b21Vc2VycyA9IHtcclxuICAgIHN1YnNjcmliZTogdXNlcnMuc3Vic2NyaWJlLFxyXG4gICAgc2V0VXNlcnM6ICh1c2Vyc0RhdGEpID0+IHtcclxuICAgICAgICB1c2Vycy5zZXQodXNlcnNEYXRhKTtcclxuICAgIH0sXHJcbiAgICBhZGRVc2VyOiAoKSA9PiB7fSxcclxuICAgIHVwZGF0ZVVzZXI6ICgpID0+IHt9LFxyXG4gICAgZGVsZXRlVXNlcjogKCkgPT4ge31cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGN1c3RvbVVzZXJzO1xyXG4iLCI8c3ZlbHRlOmNvbXBvbmVudFxuICB0aGlzPXtjb21wb25lbnR9XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgdXNlPXtbXG4gICAgW1xuICAgICAgUmlwcGxlLFxuICAgICAge1xuICAgICAgICByaXBwbGUsXG4gICAgICAgIHVuYm91bmRlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBkaXNhYmxlZDogISEkJHJlc3RQcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgYWRkQ2xhc3MsXG4gICAgICAgIHJlbW92ZUNsYXNzLFxuICAgICAgICBhZGRTdHlsZSxcbiAgICAgIH0sXG4gICAgXSxcbiAgICBmb3J3YXJkRXZlbnRzLFxuICAgIC4uLnVzZSxcbiAgXX1cbiAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICBbY2xhc3NOYW1lXTogdHJ1ZSxcbiAgICAnbWRjLWJ1dHRvbic6IHRydWUsXG4gICAgJ21kYy1idXR0b24tLXJhaXNlZCc6IHZhcmlhbnQgPT09ICdyYWlzZWQnLFxuICAgICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJzogdmFyaWFudCA9PT0gJ3VuZWxldmF0ZWQnLFxuICAgICdtZGMtYnV0dG9uLS1vdXRsaW5lZCc6IHZhcmlhbnQgPT09ICdvdXRsaW5lZCcsXG4gICAgJ3NtdWktYnV0dG9uLS1jb2xvci1zZWNvbmRhcnknOiBjb2xvciA9PT0gJ3NlY29uZGFyeScsXG4gICAgJ21kYy1idXR0b24tLXRvdWNoJzogdG91Y2gsXG4gICAgJ21kYy1jYXJkX19hY3Rpb24nOiBjb250ZXh0ID09PSAnY2FyZDphY3Rpb24nLFxuICAgICdtZGMtY2FyZF9fYWN0aW9uLS1idXR0b24nOiBjb250ZXh0ID09PSAnY2FyZDphY3Rpb24nLFxuICAgICdtZGMtZGlhbG9nX19idXR0b24nOiBjb250ZXh0ID09PSAnZGlhbG9nOmFjdGlvbicsXG4gICAgJ21kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJzogY29udGV4dCA9PT0gJ3RvcC1hcHAtYmFyOm5hdmlnYXRpb24nLFxuICAgICdtZGMtdG9wLWFwcC1iYXJfX2FjdGlvbi1pdGVtJzogY29udGV4dCA9PT0gJ3RvcC1hcHAtYmFyOmFjdGlvbicsXG4gICAgJ21kYy1zbmFja2Jhcl9fYWN0aW9uJzogY29udGV4dCA9PT0gJ3NuYWNrYmFyOmFjdGlvbnMnLFxuICAgICdtZGMtYmFubmVyX19zZWNvbmRhcnktYWN0aW9uJzogY29udGV4dCA9PT0gJ2Jhbm5lcicgJiYgc2Vjb25kYXJ5LFxuICAgICdtZGMtYmFubmVyX19wcmltYXJ5LWFjdGlvbic6IGNvbnRleHQgPT09ICdiYW5uZXInICYmICFzZWNvbmRhcnksXG4gICAgJ21kYy10b29sdGlwX19hY3Rpb24nOiBjb250ZXh0ID09PSAndG9vbHRpcDpyaWNoLWFjdGlvbnMnLFxuICAgIC4uLmludGVybmFsQ2xhc3NlcyxcbiAgfSl9XG4gIHN0eWxlPXtPYmplY3QuZW50cmllcyhpbnRlcm5hbFN0eWxlcylcbiAgICAubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBgJHtuYW1lfTogJHt2YWx1ZX07YClcbiAgICAuY29uY2F0KFtzdHlsZV0pXG4gICAgLmpvaW4oJyAnKX1cbiAgey4uLmFjdGlvblByb3B9XG4gIHsuLi5kZWZhdWx0UHJvcH1cbiAgey4uLnNlY29uZGFyeVByb3B9XG4gIHtocmVmfVxuICBvbjpjbGljaz17aGFuZGxlQ2xpY2t9XG4gIHsuLi4kJHJlc3RQcm9wc31cbiAgPjxkaXYgY2xhc3M9XCJtZGMtYnV0dG9uX19yaXBwbGVcIiAvPlxuICA8c2xvdCAvPnsjaWYgdG91Y2h9PGRpdiBjbGFzcz1cIm1kYy1idXR0b25fX3RvdWNoXCIgLz57L2lmfTwvc3ZlbHRlOmNvbXBvbmVudFxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBzZXRDb250ZXh0LCBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHtcbiAgICBmb3J3YXJkRXZlbnRzQnVpbGRlcixcbiAgICBjbGFzc01hcCxcbiAgICBkaXNwYXRjaCxcbiAgfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuICBpbXBvcnQgUmlwcGxlIGZyb20gJ0BzbXVpL3JpcHBsZSc7XG4gIGltcG9ydCBBIGZyb20gJ0BzbXVpL2NvbW1vbi9BLnN2ZWx0ZSc7XG4gIGltcG9ydCBCdXR0b24gZnJvbSAnQHNtdWkvY29tbW9uL0J1dHRvbi5zdmVsdGUnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbiAgZXhwb3J0IGxldCBzdHlsZSA9ICcnO1xuICBleHBvcnQgbGV0IHJpcHBsZSA9IHRydWU7XG4gIGV4cG9ydCBsZXQgY29sb3IgPSAncHJpbWFyeSc7XG4gIGV4cG9ydCBsZXQgdmFyaWFudCA9ICd0ZXh0JztcbiAgZXhwb3J0IGxldCB0b3VjaCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGhyZWYgPSBudWxsO1xuICBleHBvcnQgbGV0IGFjdGlvbiA9ICdjbG9zZSc7XG4gIGxldCBkZWZhdWx0QWN0aW9uID0gZmFsc2U7XG4gIGV4cG9ydCB7IGRlZmF1bHRBY3Rpb24gYXMgZGVmYXVsdCB9O1xuICBleHBvcnQgbGV0IHNlY29uZGFyeSA9IGZhbHNlO1xuXG4gIGxldCBlbGVtZW50O1xuICBsZXQgaW50ZXJuYWxDbGFzc2VzID0ge307XG4gIGxldCBpbnRlcm5hbFN0eWxlcyA9IHt9O1xuICBsZXQgY29udGV4dCA9IGdldENvbnRleHQoJ1NNVUk6YnV0dG9uOmNvbnRleHQnKTtcblxuICBleHBvcnQgbGV0IGNvbXBvbmVudCA9IGhyZWYgPT0gbnVsbCA/IEJ1dHRvbiA6IEE7XG5cbiAgJDogYWN0aW9uUHJvcCA9XG4gICAgY29udGV4dCA9PT0gJ2RpYWxvZzphY3Rpb24nICYmIGFjdGlvbiAhPSBudWxsXG4gICAgICA/IHsgJ2RhdGEtbWRjLWRpYWxvZy1hY3Rpb24nOiBhY3Rpb24gfVxuICAgICAgOiB7IGFjdGlvbjogJCRwcm9wcy5hY3Rpb24gfTtcbiAgJDogZGVmYXVsdFByb3AgPVxuICAgIGNvbnRleHQgPT09ICdkaWFsb2c6YWN0aW9uJyAmJiBkZWZhdWx0QWN0aW9uXG4gICAgICA/IHsgJ2RhdGEtbWRjLWRpYWxvZy1idXR0b24tZGVmYXVsdCc6ICcnIH1cbiAgICAgIDogeyBkZWZhdWx0OiAkJHByb3BzLmRlZmF1bHQgfTtcbiAgJDogc2Vjb25kYXJ5UHJvcCA9XG4gICAgY29udGV4dCA9PT0gJ2Jhbm5lcicgPyB7fSA6IHsgc2Vjb25kYXJ5OiAkJHByb3BzLnNlY29uZGFyeSB9O1xuXG4gIHNldENvbnRleHQoJ1NNVUk6bGFiZWw6Y29udGV4dCcsICdidXR0b24nKTtcbiAgc2V0Q29udGV4dCgnU01VSTppY29uOmNvbnRleHQnLCAnYnV0dG9uJyk7XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgaWYgKCFpbnRlcm5hbENsYXNzZXNbY2xhc3NOYW1lXSkge1xuICAgICAgaW50ZXJuYWxDbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICAgIGlmICghKGNsYXNzTmFtZSBpbiBpbnRlcm5hbENsYXNzZXMpIHx8IGludGVybmFsQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICBpbnRlcm5hbENsYXNzZXNbY2xhc3NOYW1lXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGludGVybmFsU3R5bGVzW25hbWVdICE9IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGludGVybmFsU3R5bGVzW25hbWVdO1xuICAgICAgICBpbnRlcm5hbFN0eWxlcyA9IGludGVybmFsU3R5bGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxTdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gJ2Jhbm5lcicpIHtcbiAgICAgIGRpc3BhdGNoKFxuICAgICAgICBnZXRFbGVtZW50KCksXG4gICAgICAgIHNlY29uZGFyeVxuICAgICAgICAgID8gJ1NNVUk6YmFubmVyOmJ1dHRvbjpzZWNvbmRhcnlBY3Rpb25DbGljaydcbiAgICAgICAgICA6ICdTTVVJOmJhbm5lcjpidXR0b246cHJpbWFyeUFjdGlvbkNsaWNrJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50KCk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHN2ZWx0ZTpjb21wb25lbnRcbiAgdGhpcz17Y29tcG9uZW50fVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZT17W2ZvcndhcmRFdmVudHMsIC4uLnVzZV19XG4gIGNsYXNzPXtjbGFzc01hcCh7XG4gICAgW2NsYXNzTmFtZV06IHRydWUsXG4gICAgJ21kYy1idXR0b25fX2xhYmVsJzogY29udGV4dCA9PT0gJ2J1dHRvbicsXG4gICAgJ21kYy1mYWJfX2xhYmVsJzogY29udGV4dCA9PT0gJ2ZhYicsXG4gICAgJ21kYy10YWJfX3RleHQtbGFiZWwnOiBjb250ZXh0ID09PSAndGFiJyxcbiAgICAnbWRjLWltYWdlLWxpc3RfX2xhYmVsJzogY29udGV4dCA9PT0gJ2ltYWdlLWxpc3QnLFxuICAgICdtZGMtc25hY2tiYXJfX2xhYmVsJzogY29udGV4dCA9PT0gJ3NuYWNrYmFyJyxcbiAgICAnbWRjLWJhbm5lcl9fdGV4dCc6IGNvbnRleHQgPT09ICdiYW5uZXInLFxuICAgICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fbGFiZWwnOiBjb250ZXh0ID09PSAnc2VnbWVudGVkLWJ1dHRvbicsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWwnOlxuICAgICAgY29udGV4dCA9PT0gJ2RhdGEtdGFibGU6cGFnaW5hdGlvbicsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC1sYWJlbCc6XG4gICAgICBjb250ZXh0ID09PSAnZGF0YS10YWJsZTpzb3J0YWJsZS1oZWFkZXItY2VsbCcsXG4gIH0pfVxuICB7Li4uY29udGV4dCA9PT0gJ3NuYWNrYmFyJyA/IHsgJ2FyaWEtYXRvbWljJzogJ2ZhbHNlJyB9IDoge319XG4gIHt0YWJpbmRleH1cbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvc3ZlbHRlOmNvbXBvbmVudFxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIGNsYXNzTWFwLCB1c2VBY3Rpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG4gIGltcG9ydCBTcGFuIGZyb20gJy4vU3Bhbi5zdmVsdGUnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcblxuICBsZXQgZWxlbWVudDtcblxuICBleHBvcnQgbGV0IGNvbXBvbmVudCA9IFNwYW47XG5cbiAgY29uc3QgY29udGV4dCA9IGdldENvbnRleHQoJ1NNVUk6bGFiZWw6Y29udGV4dCcpO1xuICBjb25zdCB0YWJpbmRleCA9IGdldENvbnRleHQoJ1NNVUk6bGFiZWw6dGFiaW5kZXgnKTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50KCk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIENTUyBjbGFzcyBuYW1lcyB1c2VkIGluIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IHZhciBjc3NDbGFzc2VzID0ge1xuICAgIENFTEw6ICdtZGMtZGF0YS10YWJsZV9fY2VsbCcsXG4gICAgQ0VMTF9OVU1FUklDOiAnbWRjLWRhdGEtdGFibGVfX2NlbGwtLW51bWVyaWMnLFxuICAgIENPTlRFTlQ6ICdtZGMtZGF0YS10YWJsZV9fY29udGVudCcsXG4gICAgSEVBREVSX0NFTEw6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwnLFxuICAgIEhFQURFUl9DRUxMX0xBQkVMOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLWxhYmVsJyxcbiAgICBIRUFERVJfQ0VMTF9TT1JURUQ6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZCcsXG4gICAgSEVBREVSX0NFTExfU09SVEVEX0RFU0NFTkRJTkc6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZC1kZXNjZW5kaW5nJyxcbiAgICBIRUFERVJfQ0VMTF9XSVRIX1NPUlQ6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXdpdGgtc29ydCcsXG4gICAgSEVBREVSX0NFTExfV1JBUFBFUjogJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC13cmFwcGVyJyxcbiAgICBIRUFERVJfUk9XOiAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1yb3cnLFxuICAgIEhFQURFUl9ST1dfQ0hFQ0tCT1g6ICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvdy1jaGVja2JveCcsXG4gICAgSU5fUFJPR1JFU1M6ICdtZGMtZGF0YS10YWJsZS0taW4tcHJvZ3Jlc3MnLFxuICAgIExJTkVBUl9QUk9HUkVTUzogJ21kYy1kYXRhLXRhYmxlX19saW5lYXItcHJvZ3Jlc3MnLFxuICAgIFBBR0lOQVRJT05fUk9XU19QRVJfUEFHRV9MQUJFTDogJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWwnLFxuICAgIFBBR0lOQVRJT05fUk9XU19QRVJfUEFHRV9TRUxFQ1Q6ICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCcsXG4gICAgUFJPR1JFU1NfSU5ESUNBVE9SOiAnbWRjLWRhdGEtdGFibGVfX3Byb2dyZXNzLWluZGljYXRvcicsXG4gICAgUk9PVDogJ21kYy1kYXRhLXRhYmxlJyxcbiAgICBST1c6ICdtZGMtZGF0YS10YWJsZV9fcm93JyxcbiAgICBST1dfQ0hFQ0tCT1g6ICdtZGMtZGF0YS10YWJsZV9fcm93LWNoZWNrYm94JyxcbiAgICBST1dfU0VMRUNURUQ6ICdtZGMtZGF0YS10YWJsZV9fcm93LS1zZWxlY3RlZCcsXG4gICAgU09SVF9JQ09OX0JVVFRPTjogJ21kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uJyxcbiAgICBTT1JUX1NUQVRVU19MQUJFTDogJ21kYy1kYXRhLXRhYmxlX19zb3J0LXN0YXR1cy1sYWJlbCcsXG4gICAgVEFCTEVfQ09OVEFJTkVSOiAnbWRjLWRhdGEtdGFibGVfX3RhYmxlLWNvbnRhaW5lcicsXG59O1xuLyoqXG4gKiBET00gYXR0cmlidXRlcyB1c2VkIGluIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IHZhciBhdHRyaWJ1dGVzID0ge1xuICAgIEFSSUFfU0VMRUNURUQ6ICdhcmlhLXNlbGVjdGVkJyxcbiAgICBBUklBX1NPUlQ6ICdhcmlhLXNvcnQnLFxufTtcbi8qKlxuICogTGlzdCBvZiBkYXRhIGF0dHJpYnV0ZXMgdXNlZCBpbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCB2YXIgZGF0YUF0dHJpYnV0ZXMgPSB7XG4gICAgQ09MVU1OX0lEOiAnZGF0YS1jb2x1bW4taWQnLFxuICAgIFJPV19JRDogJ2RhdGEtcm93LWlkJyxcbn07XG4vKipcbiAqIENTUyBzZWxlY3RvcnMgdXNlZCBpbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCB2YXIgc2VsZWN0b3JzID0ge1xuICAgIENPTlRFTlQ6IFwiLlwiICsgY3NzQ2xhc3Nlcy5DT05URU5ULFxuICAgIEhFQURFUl9DRUxMOiBcIi5cIiArIGNzc0NsYXNzZXMuSEVBREVSX0NFTEwsXG4gICAgSEVBREVSX0NFTExfV0lUSF9TT1JUOiBcIi5cIiArIGNzc0NsYXNzZXMuSEVBREVSX0NFTExfV0lUSF9TT1JULFxuICAgIEhFQURFUl9ST1c6IFwiLlwiICsgY3NzQ2xhc3Nlcy5IRUFERVJfUk9XLFxuICAgIEhFQURFUl9ST1dfQ0hFQ0tCT1g6IFwiLlwiICsgY3NzQ2xhc3Nlcy5IRUFERVJfUk9XX0NIRUNLQk9YLFxuICAgIFBST0dSRVNTX0lORElDQVRPUjogXCIuXCIgKyBjc3NDbGFzc2VzLlBST0dSRVNTX0lORElDQVRPUixcbiAgICBST1c6IFwiLlwiICsgY3NzQ2xhc3Nlcy5ST1csXG4gICAgUk9XX0NIRUNLQk9YOiBcIi5cIiArIGNzc0NsYXNzZXMuUk9XX0NIRUNLQk9YLFxuICAgIFJPV19TRUxFQ1RFRDogXCIuXCIgKyBjc3NDbGFzc2VzLlJPV19TRUxFQ1RFRCxcbiAgICBTT1JUX0lDT05fQlVUVE9OOiBcIi5cIiArIGNzc0NsYXNzZXMuU09SVF9JQ09OX0JVVFRPTixcbiAgICBTT1JUX1NUQVRVU19MQUJFTDogXCIuXCIgKyBjc3NDbGFzc2VzLlNPUlRfU1RBVFVTX0xBQkVMLFxufTtcbi8qKlxuICogTWVzc2FnZXMgdXNlZCBpbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCB2YXIgbWVzc2FnZXMgPSB7XG4gICAgU09SVEVEX0lOX0RFU0NFTkRJTkc6ICdTb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlcicsXG4gICAgU09SVEVEX0lOX0FTQ0VORElORzogJ1NvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXInLFxufTtcbi8qKlxuICogQXR0cmlidXRlcyBhbmQgc2VsZWN0b3JzIHVzZWQgaW4gY29tcG9uZW50LlxuICogQGRlcHJlY2F0ZWQgVXNlIGBhdHRyaWJ1dGVzYCwgYGRhdGFBdHRyaWJ1dGVzYCBhbmQgYHNlbGVjdG9yc2AgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHZhciBzdHJpbmdzID0ge1xuICAgIEFSSUFfU0VMRUNURUQ6IGF0dHJpYnV0ZXMuQVJJQV9TRUxFQ1RFRCxcbiAgICBBUklBX1NPUlQ6IGF0dHJpYnV0ZXMuQVJJQV9TT1JULFxuICAgIERBVEFfUk9XX0lEX0FUVFI6IGRhdGFBdHRyaWJ1dGVzLlJPV19JRCxcbiAgICBIRUFERVJfUk9XX0NIRUNLQk9YX1NFTEVDVE9SOiBzZWxlY3RvcnMuSEVBREVSX1JPV19DSEVDS0JPWCxcbiAgICBST1dfQ0hFQ0tCT1hfU0VMRUNUT1I6IHNlbGVjdG9ycy5ST1dfQ0hFQ0tCT1gsXG4gICAgUk9XX1NFTEVDVEVEX1NFTEVDVE9SOiBzZWxlY3RvcnMuUk9XX1NFTEVDVEVELFxuICAgIFJPV19TRUxFQ1RPUjogc2VsZWN0b3JzLlJPVyxcbn07XG4vKipcbiAqIFNvcnQgdmFsdWVzIGRlZmluZWQgYnkgQVJJQS5cbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEvc3RhdGVzX2FuZF9wcm9wZXJ0aWVzI2FyaWEtc29ydFxuICovXG5leHBvcnQgdmFyIFNvcnRWYWx1ZTtcbihmdW5jdGlvbiAoU29ydFZhbHVlKSB7XG4gICAgLy8gSXRlbXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhpcyBjb2x1bW4uXG4gICAgU29ydFZhbHVlW1wiQVNDRU5ESU5HXCJdID0gXCJhc2NlbmRpbmdcIjtcbiAgICAvLyBJdGVtcyBhcmUgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXIgYnkgdGhpcyBjb2x1bW4uXG4gICAgU29ydFZhbHVlW1wiREVTQ0VORElOR1wiXSA9IFwiZGVzY2VuZGluZ1wiO1xuICAgIC8vIFRoZXJlIGlzIG5vIGRlZmluZWQgc29ydCBhcHBsaWVkIHRvIHRoZSBjb2x1bW4uXG4gICAgU29ydFZhbHVlW1wiTk9ORVwiXSA9IFwibm9uZVwiO1xuICAgIC8vIEEgc29ydCBhbGdvcml0aG0gb3RoZXIgdGhhbiBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBoYXMgYmVlbiBhcHBsaWVkLlxuICAgIFNvcnRWYWx1ZVtcIk9USEVSXCJdID0gXCJvdGhlclwiO1xufSkoU29ydFZhbHVlIHx8IChTb3J0VmFsdWUgPSB7fSkpO1xuLyoqXG4gKiBFdmVudCBuYW1lcyB1c2VkIGluIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IHZhciBldmVudHMgPSB7XG4gICAgUk9XX1NFTEVDVElPTl9DSEFOR0VEOiAnTURDRGF0YVRhYmxlOnJvd1NlbGVjdGlvbkNoYW5nZWQnLFxuICAgIFNFTEVDVEVEX0FMTDogJ01EQ0RhdGFUYWJsZTpzZWxlY3RlZEFsbCcsXG4gICAgVU5TRUxFQ1RFRF9BTEw6ICdNRENEYXRhVGFibGU6dW5zZWxlY3RlZEFsbCcsXG4gICAgU09SVEVEOiAnTURDRGF0YVRhYmxlOnNvcnRlZCcsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0IHsgX19hc3NpZ24sIF9fYXdhaXRlciwgX19leHRlbmRzLCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgTURDRm91bmRhdGlvbiB9IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHsgY3NzQ2xhc3NlcywgU29ydFZhbHVlLCBzdHJpbmdzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuLyoqXG4gKiBUaGUgRm91bmRhdGlvbiBvZiBkYXRhIHRhYmxlIGNvbXBvbmVudCBjb250YWluaW5nIHB1cmUgYnVzaW5lc3MgbG9naWMsIGFueVxuICogbG9naWMgcmVxdWlyaW5nIERPTSBtYW5pcHVsYXRpb24gYXJlIGRlbGVnYXRlZCB0byBhZGFwdGVyIG1ldGhvZHMuXG4gKi9cbnZhciBNRENEYXRhVGFibGVGb3VuZGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNRENEYXRhVGFibGVGb3VuZGF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24oYWRhcHRlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgX19hc3NpZ24oX19hc3NpZ24oe30sIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIpLCBhZGFwdGVyKSkgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24sIFwiZGVmYXVsdEFkYXB0ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0F0Um93SW5kZXg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVCeUhlYWRlckNlbGxJbmRleDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH0sXG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVyQ2VsbENvdW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICAgICAgICAgIGdldEhlYWRlckNlbGxFbGVtZW50czogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICAgICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgICAgICAgICAgZ2V0Um93RWxlbWVudHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgICAgIGdldFJvd0lkQXRJbmRleDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH0sXG4gICAgICAgICAgICAgICAgZ2V0Um93SW5kZXhCeUNoaWxkRWxlbWVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgICAgICAgICBnZXRTZWxlY3RlZFJvd0NvdW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICAgICAgICAgIGdldFRhYmxlQ29udGFpbmVySGVpZ2h0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICAgICAgICAgIGdldFRhYmxlSGVhZGVySGVpZ2h0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICAgICAgICAgIGlzQ2hlY2tib3hBdFJvd0luZGV4Q2hlY2tlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgICAgaXNIZWFkZXJSb3dDaGVja2JveENoZWNrZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICAgIGlzUm93c1NlbGVjdGFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICAgIG5vdGlmeVJvd1NlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBub3RpZnlTZWxlY3RlZEFsbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIG5vdGlmeVNvcnRBY3Rpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBub3RpZnlVbnNlbGVjdGVkQWxsOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJIZWFkZXJSb3dDaGVja2JveDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUm93Q2hlY2tib3hlczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NBdFJvd0luZGV4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NOYW1lQnlIZWFkZXJDZWxsSW5kZXg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVBdFJvd0luZGV4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlQnlIZWFkZXJDZWxsSW5kZXg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICAgICAgICBzZXRDbGFzc05hbWVCeUhlYWRlckNlbGxJbmRleDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHNldEhlYWRlclJvd0NoZWNrYm94Q2hlY2tlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHNldEhlYWRlclJvd0NoZWNrYm94SW5kZXRlcm1pbmF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHNldFByb2dyZXNzSW5kaWNhdG9yU3R5bGVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICAgICAgc2V0Um93Q2hlY2tib3hDaGVja2VkQXRJbmRleDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgICAgICAgIHNldFNvcnRTdGF0dXNMYWJlbEJ5SGVhZGVyQ2VsbEluZGV4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmUtaW5pdGlhbGl6ZXMgaGVhZGVyIHJvdyBjaGVja2JveCBhbmQgcm93IGNoZWNrYm94ZXMgd2hlbiBzZWxlY3RhYmxlIHJvd3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0YWJsZS5cbiAgICAgKiBVc2UgdGhpcyBpZiByZWdpc3RlcmluZyBjaGVja2JveCBpcyBzeW5jaHJvbm91cy5cbiAgICAgKi9cbiAgICBNRENEYXRhVGFibGVGb3VuZGF0aW9uLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuaXNSb3dzU2VsZWN0YWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIucmVnaXN0ZXJIZWFkZXJSb3dDaGVja2JveCgpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlZ2lzdGVyUm93Q2hlY2tib3hlcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJSb3dDaGVja2JveFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlLWluaXRpYWxpemVzIGhlYWRlciByb3cgY2hlY2tib3ggYW5kIHJvdyBjaGVja2JveGVzIHdoZW4gc2VsZWN0YWJsZSByb3dzIGFyZSBhZGRlZCBvciByZW1vdmVkIGZyb20gdGFibGUuXG4gICAgICogVXNlIHRoaXMgaWYgcmVnaXN0ZXJpbmcgY2hlY2tib3ggaXMgYXN5bmNocm9ub3VzLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLmxheW91dEFzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWRhcHRlci5pc1Jvd3NTZWxlY3RhYmxlKCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hZGFwdGVyLnJlZ2lzdGVySGVhZGVyUm93Q2hlY2tib3goKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYWRhcHRlci5yZWdpc3RlclJvd0NoZWNrYm94ZXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyUm93Q2hlY2tib3hTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFJldHVybnMgYXJyYXkgb2Ygcm93IGVsZW1lbnRzLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0Um93RWxlbWVudHMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQXJyYXkgb2YgaGVhZGVyIGNlbGwgZWxlbWVudHMuXG4gICAgICovXG4gICAgTURDRGF0YVRhYmxlRm91bmRhdGlvbi5wcm90b3R5cGUuZ2V0SGVhZGVyQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0SGVhZGVyQ2VsbEVsZW1lbnRzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHJvdyBpZHMuIE92ZXJ3cml0ZXMgcHJldmlvdXNseSBzZWxlY3RlZCByb3dzLlxuICAgICAqIEBwYXJhbSByb3dJZHMgQXJyYXkgb2Ygcm93IGlkcyB0aGF0IG5lZWRzIHRvIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLnNldFNlbGVjdGVkUm93SWRzID0gZnVuY3Rpb24gKHJvd0lkcykge1xuICAgICAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgdGhpcy5hZGFwdGVyLmdldFJvd0NvdW50KCk7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgIHZhciByb3dJZCA9IHRoaXMuYWRhcHRlci5nZXRSb3dJZEF0SW5kZXgocm93SW5kZXgpO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChyb3dJZCAmJiByb3dJZHMuaW5kZXhPZihyb3dJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnNldFJvd0NoZWNrYm94Q2hlY2tlZEF0SW5kZXgocm93SW5kZXgsIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RSb3dBdEluZGV4KHJvd0luZGV4LCBpc1NlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEhlYWRlclJvd0NoZWNrYm94U3RhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gUmV0dXJucyBhcnJheSBvZiBhbGwgcm93IGlkcy5cbiAgICAgKi9cbiAgICBNRENEYXRhVGFibGVGb3VuZGF0aW9uLnByb3RvdHlwZS5nZXRSb3dJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dJZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRoaXMuYWRhcHRlci5nZXRSb3dDb3VudCgpOyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICByb3dJZHMucHVzaCh0aGlzLmFkYXB0ZXIuZ2V0Um93SWRBdEluZGV4KHJvd0luZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd0lkcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gUmV0dXJucyBhcnJheSBvZiBzZWxlY3RlZCByb3cgaWRzLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLmdldFNlbGVjdGVkUm93SWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dJZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRoaXMuYWRhcHRlci5nZXRSb3dDb3VudCgpOyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmlzQ2hlY2tib3hBdFJvd0luZGV4Q2hlY2tlZChyb3dJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd0lkcy5wdXNoKHRoaXMuYWRhcHRlci5nZXRSb3dJZEF0SW5kZXgocm93SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRSb3dJZHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGhlYWRlciByb3cgY2hlY2tib3ggY2hhbmdlIGV2ZW50LlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLmhhbmRsZUhlYWRlclJvd0NoZWNrYm94Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNIZWFkZXJDaGVja2VkID0gdGhpcy5hZGFwdGVyLmlzSGVhZGVyUm93Q2hlY2tib3hDaGVja2VkKCk7XG4gICAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCB0aGlzLmFkYXB0ZXIuZ2V0Um93Q291bnQoKTsgcm93SW5kZXgrKykge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnNldFJvd0NoZWNrYm94Q2hlY2tlZEF0SW5kZXgocm93SW5kZXgsIGlzSGVhZGVyQ2hlY2tlZCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFJvd0F0SW5kZXgocm93SW5kZXgsIGlzSGVhZGVyQ2hlY2tlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSGVhZGVyQ2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5vdGlmeVNlbGVjdGVkQWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIubm90aWZ5VW5zZWxlY3RlZEFsbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZSBldmVudCBvcmlnaW5hdGVkIGZyb20gcm93IGNoZWNrYm94ZXMuXG4gICAgICovXG4gICAgTURDRGF0YVRhYmxlRm91bmRhdGlvbi5wcm90b3R5cGUuaGFuZGxlUm93Q2hlY2tib3hDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJvd0luZGV4ID0gdGhpcy5hZGFwdGVyLmdldFJvd0luZGV4QnlDaGlsZEVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHJvd0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuYWRhcHRlci5pc0NoZWNrYm94QXRSb3dJbmRleENoZWNrZWQocm93SW5kZXgpO1xuICAgICAgICB0aGlzLnNlbGVjdFJvd0F0SW5kZXgocm93SW5kZXgsIHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXJSb3dDaGVja2JveFN0YXRlKCk7XG4gICAgICAgIHZhciByb3dJZCA9IHRoaXMuYWRhcHRlci5nZXRSb3dJZEF0SW5kZXgocm93SW5kZXgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIubm90aWZ5Um93U2VsZWN0aW9uQ2hhbmdlZCh7IHJvd0lkOiByb3dJZCwgcm93SW5kZXg6IHJvd0luZGV4LCBzZWxlY3RlZDogc2VsZWN0ZWQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNvcnQgYWN0aW9uIG9uIHNvcnRhYmxlIGhlYWRlciBjZWxsLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLmhhbmRsZVNvcnRBY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnREYXRhKSB7XG4gICAgICAgIHZhciBjb2x1bW5JZCA9IGV2ZW50RGF0YS5jb2x1bW5JZCwgY29sdW1uSW5kZXggPSBldmVudERhdGEuY29sdW1uSW5kZXgsIGhlYWRlckNlbGwgPSBldmVudERhdGEuaGVhZGVyQ2VsbDtcbiAgICAgICAgLy8gUmVzZXQgc29ydCBhdHRyaWJ1dGVzIC8gY2xhc3NlcyBvbiBvdGhlciBoZWFkZXIgY2VsbHMuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmFkYXB0ZXIuZ2V0SGVhZGVyQ2VsbENvdW50KCk7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzc05hbWVCeUhlYWRlckNlbGxJbmRleChpbmRleCwgY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9TT1JURUQpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzTmFtZUJ5SGVhZGVyQ2VsbEluZGV4KGluZGV4LCBjc3NDbGFzc2VzLkhFQURFUl9DRUxMX1NPUlRFRF9ERVNDRU5ESU5HKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5zZXRBdHRyaWJ1dGVCeUhlYWRlckNlbGxJbmRleChpbmRleCwgc3RyaW5ncy5BUklBX1NPUlQsIFNvcnRWYWx1ZS5OT05FKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5zZXRTb3J0U3RhdHVzTGFiZWxCeUhlYWRlckNlbGxJbmRleChpbmRleCwgU29ydFZhbHVlLk5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBhcHByb3ByaWF0ZSBzb3J0IGF0dHJpYnV0ZXMgLyBjbGFzc2VzIG9uIHRhcmdldCBoZWFkZXIgY2VsbC5cbiAgICAgICAgdGhpcy5hZGFwdGVyLnNldENsYXNzTmFtZUJ5SGVhZGVyQ2VsbEluZGV4KGNvbHVtbkluZGV4LCBjc3NDbGFzc2VzLkhFQURFUl9DRUxMX1NPUlRFRCk7XG4gICAgICAgIHZhciBjdXJyZW50U29ydFZhbHVlID0gdGhpcy5hZGFwdGVyLmdldEF0dHJpYnV0ZUJ5SGVhZGVyQ2VsbEluZGV4KGNvbHVtbkluZGV4LCBzdHJpbmdzLkFSSUFfU09SVCk7XG4gICAgICAgIHZhciBzb3J0VmFsdWUgPSBTb3J0VmFsdWUuTk9ORTtcbiAgICAgICAgLy8gU2V0IHRvIGRlc2NlbmRpbmcgaWYgc29ydGVkIG9uIGFzY2VuZGluZyBvcmRlci5cbiAgICAgICAgaWYgKGN1cnJlbnRTb3J0VmFsdWUgPT09IFNvcnRWYWx1ZS5BU0NFTkRJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5zZXRDbGFzc05hbWVCeUhlYWRlckNlbGxJbmRleChjb2x1bW5JbmRleCwgY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9TT1JURURfREVTQ0VORElORyk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuc2V0QXR0cmlidXRlQnlIZWFkZXJDZWxsSW5kZXgoY29sdW1uSW5kZXgsIHN0cmluZ3MuQVJJQV9TT1JULCBTb3J0VmFsdWUuREVTQ0VORElORyk7XG4gICAgICAgICAgICBzb3J0VmFsdWUgPSBTb3J0VmFsdWUuREVTQ0VORElORztcbiAgICAgICAgICAgIC8vIFNldCB0byBhc2NlbmRpbmcgaWYgc29ydGVkIG9uIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFNvcnRWYWx1ZSA9PT0gU29ydFZhbHVlLkRFU0NFTkRJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzc05hbWVCeUhlYWRlckNlbGxJbmRleChjb2x1bW5JbmRleCwgY3NzQ2xhc3Nlcy5IRUFERVJfQ0VMTF9TT1JURURfREVTQ0VORElORyk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuc2V0QXR0cmlidXRlQnlIZWFkZXJDZWxsSW5kZXgoY29sdW1uSW5kZXgsIHN0cmluZ3MuQVJJQV9TT1JULCBTb3J0VmFsdWUuQVNDRU5ESU5HKTtcbiAgICAgICAgICAgIHNvcnRWYWx1ZSA9IFNvcnRWYWx1ZS5BU0NFTkRJTkc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTZXQgdG8gYXNjZW5kaW5nIGJ5IGRlZmF1bHQgd2hlbiBub3Qgc29ydGVkLlxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnNldEF0dHJpYnV0ZUJ5SGVhZGVyQ2VsbEluZGV4KGNvbHVtbkluZGV4LCBzdHJpbmdzLkFSSUFfU09SVCwgU29ydFZhbHVlLkFTQ0VORElORyk7XG4gICAgICAgICAgICBzb3J0VmFsdWUgPSBTb3J0VmFsdWUuQVNDRU5ESU5HO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXRTb3J0U3RhdHVzTGFiZWxCeUhlYWRlckNlbGxJbmRleChjb2x1bW5JbmRleCwgc29ydFZhbHVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLm5vdGlmeVNvcnRBY3Rpb24oe1xuICAgICAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgaGVhZGVyQ2VsbDogaGVhZGVyQ2VsbCxcbiAgICAgICAgICAgIHNvcnRWYWx1ZTogc29ydFZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3dzIHByb2dyZXNzIGluZGljYXRvciBibG9ja2luZyBvbmx5IHRoZSB0YWJsZSBib2R5IGNvbnRlbnQgd2hlbiBpblxuICAgICAqIGxvYWRpbmcgc3RhdGUuXG4gICAgICovXG4gICAgTURDRGF0YVRhYmxlRm91bmRhdGlvbi5wcm90b3R5cGUuc2hvd1Byb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFibGVIZWFkZXJIZWlnaHQgPSB0aGlzLmFkYXB0ZXIuZ2V0VGFibGVIZWFkZXJIZWlnaHQoKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGFibGUgY29udGVudCAoTm90IHNjcm9sbCBjb250ZW50KSBleGNsdWRpbmdcbiAgICAgICAgLy8gaGVhZGVyIHJvdyBoZWlnaHQuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmFkYXB0ZXIuZ2V0VGFibGVDb250YWluZXJIZWlnaHQoKSAtIHRhYmxlSGVhZGVySGVpZ2h0O1xuICAgICAgICB2YXIgdG9wID0gdGFibGVIZWFkZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXRQcm9ncmVzc0luZGljYXRvclN0eWxlcyh7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIFwicHhcIixcbiAgICAgICAgICAgIHRvcDogdG9wICsgXCJweFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKGNzc0NsYXNzZXMuSU5fUFJPR1JFU1MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlkZXMgcHJvZ3Jlc3MgaW5kaWNhdG9yIHdoZW4gZGF0YSB0YWJsZSBpcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLmhpZGVQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuSU5fUFJPR1JFU1MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBoZWFkZXIgcm93IGNoZWNrYm94IHN0YXRlIGJhc2VkIG9uIG51bWJlciBvZiByb3dzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLnNldEhlYWRlclJvd0NoZWNrYm94U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXIuZ2V0U2VsZWN0ZWRSb3dDb3VudCgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuc2V0SGVhZGVyUm93Q2hlY2tib3hDaGVja2VkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5zZXRIZWFkZXJSb3dDaGVja2JveEluZGV0ZXJtaW5hdGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWRhcHRlci5nZXRTZWxlY3RlZFJvd0NvdW50KCkgPT09IHRoaXMuYWRhcHRlci5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuc2V0SGVhZGVyUm93Q2hlY2tib3hDaGVja2VkKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnNldEhlYWRlclJvd0NoZWNrYm94SW5kZXRlcm1pbmF0ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuc2V0SGVhZGVyUm93Q2hlY2tib3hJbmRldGVybWluYXRlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnNldEhlYWRlclJvd0NoZWNrYm94Q2hlY2tlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGF0dHJpYnV0ZXMgb2Ygcm93IGVsZW1lbnQgYmFzZWQgb24gc2VsZWN0aW9uIHN0YXRlLlxuICAgICAqL1xuICAgIE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24ucHJvdG90eXBlLnNlbGVjdFJvd0F0SW5kZXggPSBmdW5jdGlvbiAocm93SW5kZXgsIHNlbGVjdGVkKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzQXRSb3dJbmRleChyb3dJbmRleCwgY3NzQ2xhc3Nlcy5ST1dfU0VMRUNURUQpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnNldEF0dHJpYnV0ZUF0Um93SW5kZXgocm93SW5kZXgsIHN0cmluZ3MuQVJJQV9TRUxFQ1RFRCwgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzc0F0Um93SW5kZXgocm93SW5kZXgsIGNzc0NsYXNzZXMuUk9XX1NFTEVDVEVEKTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5zZXRBdHRyaWJ1dGVBdFJvd0luZGV4KHJvd0luZGV4LCBzdHJpbmdzLkFSSUFfU0VMRUNURUQsICdmYWxzZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTURDRGF0YVRhYmxlRm91bmRhdGlvbjtcbn0oTURDRm91bmRhdGlvbikpO1xuZXhwb3J0IHsgTURDRGF0YVRhYmxlRm91bmRhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm91bmRhdGlvbi5qcy5tYXAiLCI8ZGl2XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgdXNlOnVzZUFjdGlvbnM9e3VzZX1cbiAgdXNlOmZvcndhcmRFdmVudHNcbiAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICBbY2xhc3NOYW1lXTogdHJ1ZSxcbiAgICAnbWRjLWRhdGEtdGFibGUnOiB0cnVlLFxuICAgICdtZGMtZGF0YS10YWJsZS0tc3RpY2t5LWhlYWRlcic6IHN0aWNreUhlYWRlcixcbiAgICAuLi5pbnRlcm5hbENsYXNzZXMsXG4gIH0pfVxuICBvbjpTTVVJOmNoZWNrYm94Om1vdW50PXsoKSA9PiBpbnN0YW5jZSAmJiBwb3N0TW91bnQgJiYgaW5zdGFuY2UubGF5b3V0KCl9XG4gIG9uOlNNVUk6ZGF0YS10YWJsZTpoZWFkZXI6bW91bnQ9eyhldmVudCkgPT4gKGhlYWRlciA9IGV2ZW50LmRldGFpbCl9XG4gIG9uOlNNVUk6ZGF0YS10YWJsZTpoZWFkZXI6dW5tb3VudD17KCkgPT4gKGhlYWRlciA9IHVuZGVmaW5lZCl9XG4gIG9uOlNNVUk6ZGF0YS10YWJsZTpib2R5Om1vdW50PXsoZXZlbnQpID0+IChib2R5ID0gZXZlbnQuZGV0YWlsKX1cbiAgb246U01VSTpkYXRhLXRhYmxlOmJvZHk6dW5tb3VudD17KCkgPT4gKGJvZHkgPSB1bmRlZmluZWQpfVxuICBvbjpTTVVJOmRhdGEtdGFibGU6aGVhZGVyOmNoZWNrYm94OmNoYW5nZT17KCkgPT5cbiAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5oYW5kbGVIZWFkZXJSb3dDaGVja2JveENoYW5nZSgpfVxuICBvbjpTTVVJOmRhdGEtdGFibGU6aGVhZGVyOmNsaWNrPXtoYW5kbGVIZWFkZXJSb3dDbGlja31cbiAgb246U01VSTpkYXRhLXRhYmxlOmJvZHk6Y2hlY2tib3g6Y2hhbmdlPXsoZXZlbnQpID0+XG4gICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UuaGFuZGxlUm93Q2hlY2tib3hDaGFuZ2UoZXZlbnQpfVxuICB7Li4uZXhjbHVkZSgkJHJlc3RQcm9wcywgWydjb250YWluZXIkJywgJ3RhYmxlJCddKX1cbj5cbiAgPGRpdlxuICAgIGJpbmQ6dGhpcz17Y29udGFpbmVyfVxuICAgIHVzZTp1c2VBY3Rpb25zPXtjb250YWluZXIkdXNlfVxuICAgIGNsYXNzPXtjbGFzc01hcCh7XG4gICAgICBbY29udGFpbmVyJGNsYXNzXTogdHJ1ZSxcbiAgICAgICdtZGMtZGF0YS10YWJsZV9fdGFibGUtY29udGFpbmVyJzogdHJ1ZSxcbiAgICB9KX1cbiAgICB7Li4ucHJlZml4RmlsdGVyKCQkcmVzdFByb3BzLCAnY29udGFpbmVyJCcpfVxuICA+XG4gICAgPHRhYmxlXG4gICAgICB1c2U6dXNlQWN0aW9ucz17dGFibGUkdXNlfVxuICAgICAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICAgICAgW3RhYmxlJGNsYXNzXTogdHJ1ZSxcbiAgICAgICAgJ21kYy1kYXRhLXRhYmxlX190YWJsZSc6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5wcmVmaXhGaWx0ZXIoJCRyZXN0UHJvcHMsICd0YWJsZSQnKX1cbiAgICA+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvdGFibGU+XG4gIDwvZGl2PlxuXG4gIHsjaWYgJCRzbG90cy5wcm9ncmVzc31cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cIm1kYy1kYXRhLXRhYmxlX19wcm9ncmVzcy1pbmRpY2F0b3JcIlxuICAgICAgc3R5bGU9e09iamVjdC5lbnRyaWVzKHByb2dyZXNzSW5kaWNhdG9yU3R5bGVzKVxuICAgICAgICAubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBgJHtuYW1lfTogJHt2YWx1ZX07YClcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWRhdGEtdGFibGVfX3NjcmltXCIgLz5cbiAgICAgIDxzbG90IG5hbWU9XCJwcm9ncmVzc1wiIC8+XG4gICAgPC9kaXY+XG4gIHsvaWZ9XG5cbiAgPHNsb3QgbmFtZT1cInBhZ2luYXRlXCIgLz5cbjwvZGl2PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBNRENEYXRhVGFibGVGb3VuZGF0aW9uIH0gZnJvbSAnQG1hdGVyaWFsL2RhdGEtdGFibGUnO1xuICBpbXBvcnQgeyBwb255ZmlsbCB9IGZyb20gJ0BtYXRlcmlhbC9kb20nO1xuICBpbXBvcnQgeyBvbk1vdW50LCBvbkRlc3Ryb3ksIGdldENvbnRleHQsIHNldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7XG4gICAgZm9yd2FyZEV2ZW50c0J1aWxkZXIsXG4gICAgY2xhc3NNYXAsXG4gICAgZXhjbHVkZSxcbiAgICBwcmVmaXhGaWx0ZXIsXG4gICAgdXNlQWN0aW9ucyxcbiAgICBkaXNwYXRjaCxcbiAgfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuICBjb25zdCB7IGNsb3Nlc3QgfSA9IHBvbnlmaWxsO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbiAgZXhwb3J0IGxldCBzdGlja3lIZWFkZXIgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBzb3J0YWJsZSA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHNvcnQgPSBudWxsO1xuICBleHBvcnQgbGV0IHNvcnREaXJlY3Rpb24gPSAnYXNjZW5kaW5nJztcbiAgZXhwb3J0IGxldCBzb3J0QXNjZW5kaW5nQXJpYUxhYmVsID0gJ3NvcnRlZCwgYXNjZW5kaW5nJztcbiAgZXhwb3J0IGxldCBzb3J0RGVzY2VuZGluZ0FyaWFMYWJlbCA9ICdzb3J0ZWQsIGRlc2NlbmRpbmcnO1xuICBleHBvcnQgbGV0IGNvbnRhaW5lciR1c2UgPSBbXTtcbiAgZXhwb3J0IGxldCBjb250YWluZXIkY2xhc3MgPSAnJztcbiAgZXhwb3J0IGxldCB0YWJsZSR1c2UgPSBbXTtcbiAgZXhwb3J0IGxldCB0YWJsZSRjbGFzcyA9ICcnO1xuXG4gIGxldCBlbGVtZW50O1xuICBsZXQgaW5zdGFuY2U7XG4gIGxldCBjb250YWluZXI7XG4gIGxldCBoZWFkZXI7XG4gIGxldCBib2R5O1xuICBsZXQgaW50ZXJuYWxDbGFzc2VzID0ge307XG4gIGxldCBwcm9ncmVzc0luZGljYXRvclN0eWxlcyA9IHt9O1xuICBsZXQgYWRkTGF5b3V0TGlzdGVuZXIgPSBnZXRDb250ZXh0KCdTTVVJOmFkZExheW91dExpc3RlbmVyJyk7XG4gIGxldCByZW1vdmVMYXlvdXRMaXN0ZW5lcjtcbiAgbGV0IHBvc3RNb3VudCA9IGZhbHNlO1xuICBsZXQgcHJvZ3Jlc3NDbG9zZWQgPSB3cml0YWJsZShmYWxzZSk7XG4gIGxldCBzb3J0U3RvcmUgPSB3cml0YWJsZShzb3J0KTtcbiAgbGV0IHNvcnREaXJlY3Rpb25TdG9yZSA9IHdyaXRhYmxlKHNvcnREaXJlY3Rpb24pO1xuXG4gIHNldENvbnRleHQoJ1NNVUk6Y2hlY2tib3g6Y29udGV4dCcsICdkYXRhLXRhYmxlJyk7XG4gIHNldENvbnRleHQoJ1NNVUk6bGluZWFyLXByb2dyZXNzOmNvbnRleHQnLCAnZGF0YS10YWJsZScpO1xuICBzZXRDb250ZXh0KCdTTVVJOmxpbmVhci1wcm9ncmVzczpjbG9zZWQnLCBwcm9ncmVzc0Nsb3NlZCk7XG4gIHNldENvbnRleHQoJ1NNVUk6ZGF0YS10YWJsZTpzb3J0YWJsZScsIHNvcnRhYmxlKTtcbiAgc2V0Q29udGV4dCgnU01VSTpkYXRhLXRhYmxlOnNvcnQnLCBzb3J0U3RvcmUpO1xuICBzZXRDb250ZXh0KCdTTVVJOmRhdGEtdGFibGU6c29ydERpcmVjdGlvbicsIHNvcnREaXJlY3Rpb25TdG9yZSk7XG4gIHNldENvbnRleHQoJ1NNVUk6ZGF0YS10YWJsZTpzb3J0QXNjZW5kaW5nQXJpYUxhYmVsJywgc29ydEFzY2VuZGluZ0FyaWFMYWJlbCk7XG4gIHNldENvbnRleHQoXG4gICAgJ1NNVUk6ZGF0YS10YWJsZTpzb3J0RGVzY2VuZGluZ0FyaWFMYWJlbCcsXG4gICAgc29ydERlc2NlbmRpbmdBcmlhTGFiZWxcbiAgKTtcblxuICAkOiAkc29ydFN0b3JlID0gc29ydDtcbiAgJDogJHNvcnREaXJlY3Rpb25TdG9yZSA9IHNvcnREaXJlY3Rpb247XG5cbiAgaWYgKGFkZExheW91dExpc3RlbmVyKSB7XG4gICAgcmVtb3ZlTGF5b3V0TGlzdGVuZXIgPSBhZGRMYXlvdXRMaXN0ZW5lcihsYXlvdXQpO1xuICB9XG5cbiAgbGV0IHByZXZpb3VzUHJvZ3Jlc3NDbG9zZWQgPSBudWxsO1xuICAkOiBpZiAoXG4gICAgJCRzbG90cy5wcm9ncmVzcyAmJlxuICAgIGluc3RhbmNlICYmXG4gICAgcHJldmlvdXNQcm9ncmVzc0Nsb3NlZCAhPT0gJHByb2dyZXNzQ2xvc2VkXG4gICkge1xuICAgIHByZXZpb3VzUHJvZ3Jlc3NDbG9zZWQgPSAkcHJvZ3Jlc3NDbG9zZWQ7XG4gICAgaWYgKCRwcm9ncmVzc0Nsb3NlZCkge1xuICAgICAgaW5zdGFuY2UuaGlkZVByb2dyZXNzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnNob3dQcm9ncmVzcygpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGluc3RhbmNlID0gbmV3IE1EQ0RhdGFUYWJsZUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3MsXG4gICAgICByZW1vdmVDbGFzcyxcbiAgICAgIGdldEhlYWRlckNlbGxFbGVtZW50czogKCkgPT5cbiAgICAgICAgaGVhZGVyLmNlbGxzLm1hcCgoYWNjZXNzb3IpID0+IGFjY2Vzc29yLmVsZW1lbnQpLFxuICAgICAgZ2V0SGVhZGVyQ2VsbENvdW50OiAoKSA9PiBoZWFkZXIuY2VsbHMubGVuZ3RoLFxuICAgICAgZ2V0QXR0cmlidXRlQnlIZWFkZXJDZWxsSW5kZXg6IChpbmRleCwgbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyLm9yZGVyZWRDZWxsc1tpbmRleF0uZ2V0QXR0cihuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyaWJ1dGVCeUhlYWRlckNlbGxJbmRleDogKGluZGV4LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBoZWFkZXIub3JkZXJlZENlbGxzW2luZGV4XS5hZGRBdHRyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBzZXRDbGFzc05hbWVCeUhlYWRlckNlbGxJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgaGVhZGVyLm9yZGVyZWRDZWxsc1tpbmRleF0uYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc05hbWVCeUhlYWRlckNlbGxJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgaGVhZGVyLm9yZGVyZWRDZWxsc1tpbmRleF0ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICBub3RpZnlTb3J0QWN0aW9uOiAoZGF0YSkgPT4ge1xuICAgICAgICBzb3J0ID0gZGF0YS5jb2x1bW5JZDtcbiAgICAgICAgc29ydERpcmVjdGlvbiA9IGRhdGEuc29ydFZhbHVlO1xuICAgICAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdNRENEYXRhVGFibGU6c29ydGVkJywgZGF0YSk7XG4gICAgICB9LFxuICAgICAgZ2V0VGFibGVDb250YWluZXJIZWlnaHQ6ICgpID0+IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXG4gICAgICBnZXRUYWJsZUhlYWRlckhlaWdodDogKCkgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZUhlYWRlciA9IGdldEVsZW1lbnQoKS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICcubWRjLWRhdGEtdGFibGVfX2hlYWRlci1yb3cnXG4gICAgICAgICk7XG4gICAgICAgIGlmICghdGFibGVIZWFkZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01EQ0RhdGFUYWJsZTogVGFibGUgaGVhZGVyIGVsZW1lbnQgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZUhlYWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgc2V0UHJvZ3Jlc3NJbmRpY2F0b3JTdHlsZXM6IChzdHlsZXMpID0+IHtcbiAgICAgICAgcHJvZ3Jlc3NJbmRpY2F0b3JTdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3NBdFJvd0luZGV4OiAocm93SW5kZXgsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBib2R5Lm9yZGVyZWRSb3dzW3Jvd0luZGV4XS5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgfSxcbiAgICAgIGdldFJvd0NvdW50OiAoKSA9PiBib2R5LnJvd3MubGVuZ3RoLFxuICAgICAgZ2V0Um93RWxlbWVudHM6ICgpID0+IGJvZHkucm93cy5tYXAoKGFjY2Vzc29yKSA9PiBhY2Nlc3Nvci5lbGVtZW50KSxcbiAgICAgIGdldFJvd0lkQXRJbmRleDogKHJvd0luZGV4KSA9PiBib2R5Lm9yZGVyZWRSb3dzW3Jvd0luZGV4XS5yb3dJZCxcbiAgICAgIGdldFJvd0luZGV4QnlDaGlsZEVsZW1lbnQ6IChlbCkgPT4ge1xuICAgICAgICByZXR1cm4gYm9keS5vcmRlcmVkUm93c1xuICAgICAgICAgIC5tYXAoKGFjY2Vzc29yKSA9PiBhY2Nlc3Nvci5lbGVtZW50KVxuICAgICAgICAgIC5pbmRleE9mKGNsb3Nlc3QoZWwsICcubWRjLWRhdGEtdGFibGVfX3JvdycpKTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RlZFJvd0NvdW50OiAoKSA9PlxuICAgICAgICBib2R5LnJvd3MuZmlsdGVyKChhY2Nlc3NvcikgPT4gYWNjZXNzb3Iuc2VsZWN0ZWQpLmxlbmd0aCxcbiAgICAgIGlzQ2hlY2tib3hBdFJvd0luZGV4Q2hlY2tlZDogKHJvd0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gYm9keS5vcmRlcmVkUm93c1tyb3dJbmRleF0uY2hlY2tib3g7XG4gICAgICAgIGlmIChjaGVja2JveCkge1xuICAgICAgICAgIHJldHVybiBjaGVja2JveC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBpc0hlYWRlclJvd0NoZWNrYm94Q2hlY2tlZDogKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja2JveCA9IGhlYWRlci5jaGVja2JveDtcbiAgICAgICAgaWYgKGNoZWNrYm94KSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGlzUm93c1NlbGVjdGFibGU6ICgpID0+XG4gICAgICAgICEhZ2V0RWxlbWVudCgpLnF1ZXJ5U2VsZWN0b3IoJy5tZGMtZGF0YS10YWJsZV9fcm93LWNoZWNrYm94JykgfHxcbiAgICAgICAgISFnZXRFbGVtZW50KCkucXVlcnlTZWxlY3RvcignLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItcm93LWNoZWNrYm94JyksXG4gICAgICBub3RpZnlSb3dTZWxlY3Rpb25DaGFuZ2VkOiAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSBib2R5Lm9yZGVyZWRSb3dzW2RhdGEucm93SW5kZXhdO1xuICAgICAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdNRENEYXRhVGFibGU6cm93U2VsZWN0aW9uQ2hhbmdlZCcsIHtcbiAgICAgICAgICByb3c6IHJvdy5lbGVtZW50LFxuICAgICAgICAgIHJvd0lkOiByb3cucm93SWQsXG4gICAgICAgICAgcm93SW5kZXg6IGRhdGEucm93SW5kZXgsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGRhdGEuc2VsZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG5vdGlmeVNlbGVjdGVkQWxsOiAoKSA9PiB7XG4gICAgICAgIHNldEhlYWRlclJvd0NoZWNrYm94SW5kZXRlcm1pbmF0ZShmYWxzZSk7XG4gICAgICAgIGRpc3BhdGNoKGdldEVsZW1lbnQoKSwgJ01EQ0RhdGFUYWJsZTpzZWxlY3RlZEFsbCcpO1xuICAgICAgfSxcbiAgICAgIG5vdGlmeVVuc2VsZWN0ZWRBbGw6ICgpID0+IHtcbiAgICAgICAgc2V0SGVhZGVyUm93Q2hlY2tib3hJbmRldGVybWluYXRlKGZhbHNlKTtcbiAgICAgICAgZGlzcGF0Y2goZ2V0RWxlbWVudCgpLCAnTURDRGF0YVRhYmxlOnVuc2VsZWN0ZWRBbGwnKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckhlYWRlclJvd0NoZWNrYm94OiAoKSA9PiB7XG4gICAgICAgIC8vIEhhbmRsZWQgYXV0b21hdGljYWxseS5cbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJvd0NoZWNrYm94ZXM6ICgpID0+IHtcbiAgICAgICAgLy8gSGFuZGxlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzQXRSb3dJbmRleDogKHJvd0luZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgYm9keS5vcmRlcmVkUm93c1tyb3dJbmRleF0ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyaWJ1dGVBdFJvd0luZGV4OiAocm93SW5kZXgsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGJvZHkub3JkZXJlZFJvd3Nbcm93SW5kZXhdLmFkZEF0dHIobmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldEhlYWRlclJvd0NoZWNrYm94Q2hlY2tlZDogKGNoZWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tib3ggPSBoZWFkZXIuY2hlY2tib3g7XG4gICAgICAgIGlmIChjaGVja2JveCkge1xuICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0SGVhZGVyUm93Q2hlY2tib3hJbmRldGVybWluYXRlLFxuICAgICAgc2V0Um93Q2hlY2tib3hDaGVja2VkQXRJbmRleDogKHJvd0luZGV4LCBjaGVja2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gYm9keS5vcmRlcmVkUm93c1tyb3dJbmRleF0uY2hlY2tib3g7XG4gICAgICAgIGlmIChjaGVja2JveCkge1xuICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0U29ydFN0YXR1c0xhYmVsQnlIZWFkZXJDZWxsSW5kZXg6IChfY29sdW1uSW5kZXgsIF9zb3J0VmFsdWUpID0+IHtcbiAgICAgICAgLy8gSGFuZGxlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGluc3RhbmNlLmluaXQoKTtcblxuICAgIGluc3RhbmNlLmxheW91dCgpO1xuXG4gICAgcG9zdE1vdW50ID0gdHJ1ZTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgb25EZXN0cm95KCgpID0+IHtcbiAgICBpZiAocmVtb3ZlTGF5b3V0TGlzdGVuZXIpIHtcbiAgICAgIHJlbW92ZUxheW91dExpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICBpZiAoIWludGVybmFsQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICBpbnRlcm5hbENsYXNzZXNbY2xhc3NOYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgaWYgKCEoY2xhc3NOYW1lIGluIGludGVybmFsQ2xhc3NlcykgfHwgaW50ZXJuYWxDbGFzc2VzW2NsYXNzTmFtZV0pIHtcbiAgICAgIGludGVybmFsQ2xhc3Nlc1tjbGFzc05hbWVdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGVhZGVyUm93Q2hlY2tib3hJbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGUpIHtcbiAgICBjb25zdCBjaGVja2JveCA9IGhlYWRlci5jaGVja2JveDtcbiAgICBpZiAoY2hlY2tib3gpIHtcbiAgICAgIGNoZWNrYm94LmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhlYWRlclJvd0NsaWNrKGV2ZW50KSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlckNlbGwgPSBjbG9zZXN0KFxuICAgICAgZXZlbnQuZGV0YWlsLnRhcmdldCxcbiAgICAgICcubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS13aXRoLXNvcnQnXG4gICAgKTtcblxuICAgIGlmICghaGVhZGVyQ2VsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yZGVyZWRDZWxscyA9IGhlYWRlci5vcmRlcmVkQ2VsbHM7XG5cbiAgICBjb25zdCBjb2x1bW5JbmRleCA9IG9yZGVyZWRDZWxsc1xuICAgICAgLm1hcCgoYWNjZXNzb3IpID0+IGFjY2Vzc29yLmVsZW1lbnQpXG4gICAgICAuaW5kZXhPZihoZWFkZXJDZWxsKTtcbiAgICBpZiAoY29sdW1uSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbHVtbklkID0gb3JkZXJlZENlbGxzW2NvbHVtbkluZGV4XS5jb2x1bW5JZDtcblxuICAgIGluc3RhbmNlLmhhbmRsZVNvcnRBY3Rpb24oeyBjb2x1bW5JZCwgY29sdW1uSW5kZXgsIGhlYWRlckNlbGwgfSk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5sYXlvdXQoKTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG48L3NjcmlwdD5cbiIsIjx0aGVhZFxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZTp1c2VBY3Rpb25zPXt1c2V9XG4gIHVzZTpmb3J3YXJkRXZlbnRzXG4gIG9uOlNNVUk6Y2hlY2tib3g6bW91bnQ9eyhldmVudCkgPT4gKGNoZWNrYm94ID0gZXZlbnQuZGV0YWlsKX1cbiAgb246U01VSTpjaGVja2JveDp1bm1vdW50PXsoKSA9PiAoY2hlY2tib3ggPSB1bmRlZmluZWQpfVxuICBvbjpTTVVJOmRhdGEtdGFibGU6Y2VsbDptb3VudD17aGFuZGxlQ2VsbE1vdW50fVxuICBvbjpTTVVJOmRhdGEtdGFibGU6Y2VsbDp1bm1vdW50PXtoYW5kbGVDZWxsVW5tb3VudH1cbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvdGhlYWRcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCwgc2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7XG4gICAgZm9yd2FyZEV2ZW50c0J1aWxkZXIsXG4gICAgdXNlQWN0aW9ucyxcbiAgICBkaXNwYXRjaCxcbiAgfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcblxuICBsZXQgZWxlbWVudDtcbiAgbGV0IGNoZWNrYm94O1xuICBsZXQgY2VsbHMgPSBbXTtcbiAgY29uc3QgY2VsbEFjY2Vzc29yTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICBzZXRDb250ZXh0KCdTTVVJOmRhdGEtdGFibGU6cm93OmhlYWRlcicsIHRydWUpO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGNvbnN0IGFjY2Vzc29yID0ge1xuICAgICAgZ2V0IGNlbGxzKCkge1xuICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgICB9LFxuICAgICAgZ2V0IG9yZGVyZWRDZWxscygpIHtcbiAgICAgICAgcmV0dXJuIGdldE9yZGVyZWRDZWxscygpO1xuICAgICAgfSxcbiAgICAgIGdldCBjaGVja2JveCgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrYm94O1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZGlzcGF0Y2goZ2V0RWxlbWVudCgpLCAnU01VSTpkYXRhLXRhYmxlOmhlYWRlcjptb3VudCcsIGFjY2Vzc29yKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdTTVVJOmRhdGEtdGFibGU6aGVhZGVyOnVubW91bnQnKTtcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBoYW5kbGVDZWxsTW91bnQoZXZlbnQpIHtcbiAgICBjZWxscy5wdXNoKGV2ZW50LmRldGFpbCk7XG4gICAgY2VsbEFjY2Vzc29yTWFwLnNldChldmVudC5kZXRhaWwuZWxlbWVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNlbGxVbm1vdW50KGV2ZW50KSB7XG4gICAgY29uc3QgaWR4ID0gY2VsbHMuaW5kZXhPZihldmVudC5kZXRhaWwpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICBjZWxscy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIGNlbGxzID0gY2VsbHM7XG4gICAgfVxuICAgIGNlbGxBY2Nlc3Nvck1hcC5kZWxldGUoZXZlbnQuZGV0YWlsLmVsZW1lbnQpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JkZXJlZENlbGxzKCkge1xuICAgIHJldHVybiBbLi4uZ2V0RWxlbWVudCgpLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwnKV1cbiAgICAgIC5tYXAoKGVsZW1lbnQpID0+IGNlbGxBY2Nlc3Nvck1hcC5nZXQoZWxlbWVudCkpXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAoYWNjZXNzb3IpID0+IGFjY2Vzc29yICYmIGFjY2Vzc29yLl9zbXVpX2RhdGFfdGFibGVfaGVhZGVyX2NlbGxfYWNjZXNzb3JcbiAgICAgICk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuPC9zY3JpcHQ+XG4iLCI8dGJvZHlcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICB1c2U6dXNlQWN0aW9ucz17dXNlfVxuICB1c2U6Zm9yd2FyZEV2ZW50c1xuICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgIFtjbGFzc05hbWVdOiB0cnVlLFxuICAgICdtZGMtZGF0YS10YWJsZV9fY29udGVudCc6IHRydWUsXG4gIH0pfVxuICBvbjpTTVVJOmRhdGEtdGFibGU6cm93Om1vdW50PXtoYW5kbGVSb3dNb3VudH1cbiAgb246U01VSTpkYXRhLXRhYmxlOnJvdzp1bm1vdW50PXtoYW5kbGVSb3dVbm1vdW50fVxuICB7Li4uJCRyZXN0UHJvcHN9PjxzbG90IC8+PC90Ym9keVxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50LCBzZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHtcbiAgICBmb3J3YXJkRXZlbnRzQnVpbGRlcixcbiAgICBjbGFzc01hcCxcbiAgICB1c2VBY3Rpb25zLFxuICAgIGRpc3BhdGNoLFxuICB9IGZyb20gJ0BzbXVpL2NvbW1vbi9pbnRlcm5hbC5qcyc7XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gIGV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xuXG4gIGxldCBlbGVtZW50O1xuICBsZXQgcm93cyA9IFtdO1xuICBjb25zdCByb3dBY2Nlc3Nvck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgc2V0Q29udGV4dCgnU01VSTpkYXRhLXRhYmxlOnJvdzpoZWFkZXInLCBmYWxzZSk7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSB7XG4gICAgICBnZXQgcm93cygpIHtcbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICB9LFxuICAgICAgZ2V0IG9yZGVyZWRSb3dzKCkge1xuICAgICAgICByZXR1cm4gZ2V0T3JkZXJlZFJvd3MoKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGRpc3BhdGNoKGdldEVsZW1lbnQoKSwgJ1NNVUk6ZGF0YS10YWJsZTpib2R5Om1vdW50JywgYWNjZXNzb3IpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRpc3BhdGNoKGdldEVsZW1lbnQoKSwgJ1NNVUk6ZGF0YS10YWJsZTpib2R5OnVubW91bnQnKTtcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBoYW5kbGVSb3dNb3VudChldmVudCkge1xuICAgIHJvd3MucHVzaChldmVudC5kZXRhaWwpO1xuICAgIHJvd0FjY2Vzc29yTWFwLnNldChldmVudC5kZXRhaWwuZWxlbWVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJvd1VubW91bnQoZXZlbnQpIHtcbiAgICBjb25zdCBpZHggPSByb3dzLmluZGV4T2YoZXZlbnQuZGV0YWlsKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgcm93cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJvd3MgPSByb3dzO1xuICAgIH1cbiAgICByb3dBY2Nlc3Nvck1hcC5kZWxldGUoZXZlbnQuZGV0YWlsLmVsZW1lbnQpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JkZXJlZFJvd3MoKSB7XG4gICAgcmV0dXJuIFsuLi5nZXRFbGVtZW50KCkucXVlcnlTZWxlY3RvckFsbCgnLm1kYy1kYXRhLXRhYmxlX19yb3cnKV1cbiAgICAgIC5tYXAoKGVsZW1lbnQpID0+IHJvd0FjY2Vzc29yTWFwLmdldChlbGVtZW50KSlcbiAgICAgIC5maWx0ZXIoKGFjY2Vzc29yKSA9PiBhY2Nlc3NvciAmJiBhY2Nlc3Nvci5fc211aV9kYXRhX3RhYmxlX3Jvd19hY2Nlc3Nvcik7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuPC9zY3JpcHQ+XG4iLCI8dHJcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICB1c2U6dXNlQWN0aW9ucz17dXNlfVxuICB1c2U6Zm9yd2FyZEV2ZW50c1xuICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgIFtjbGFzc05hbWVdOiB0cnVlLFxuICAgICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvdyc6IGhlYWRlcixcbiAgICAnbWRjLWRhdGEtdGFibGVfX3Jvdyc6ICFoZWFkZXIsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19yb3ctLXNlbGVjdGVkJzogIWhlYWRlciAmJiBjaGVja2JveCAmJiBjaGVja2JveC5jaGVja2VkLFxuICAgIC4uLmludGVybmFsQ2xhc3NlcyxcbiAgfSl9XG4gIG9uOmNsaWNrPXsoZXZlbnQpID0+IGhlYWRlciAmJiBub3RpZnlIZWFkZXJDbGljayhldmVudCl9XG4gIG9uOlNNVUk6Y2hlY2tib3g6bW91bnQ9eyhldmVudCkgPT4gKGNoZWNrYm94ID0gZXZlbnQuZGV0YWlsKX1cbiAgb246U01VSTpjaGVja2JveDp1bm1vdW50PXsoKSA9PiAoY2hlY2tib3ggPSB1bmRlZmluZWQpfVxuICBhcmlhLXNlbGVjdGVkPXtjaGVja2JveCA/IChjaGVja2JveC5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJykgOiBudWxsfVxuICB7Li4uaW50ZXJuYWxBdHRyc31cbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvdHJcbj5cblxuPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGxldCBjb3VudGVyID0gMDtcbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50LCBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHtcbiAgICBmb3J3YXJkRXZlbnRzQnVpbGRlcixcbiAgICBjbGFzc01hcCxcbiAgICB1c2VBY3Rpb25zLFxuICAgIGRpc3BhdGNoLFxuICB9IGZyb20gJ0BzbXVpL2NvbW1vbi9pbnRlcm5hbC5qcyc7XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gIGV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xuICBleHBvcnQgbGV0IHJvd0lkID0gJ1NNVUktZGF0YS10YWJsZS1yb3ctJyArIGNvdW50ZXIrKztcblxuICBsZXQgZWxlbWVudDtcbiAgbGV0IGNoZWNrYm94O1xuICBsZXQgaW50ZXJuYWxDbGFzc2VzID0ge307XG4gIGxldCBpbnRlcm5hbEF0dHJzID0ge307XG4gIGxldCBoZWFkZXIgPSBnZXRDb250ZXh0KCdTTVVJOmRhdGEtdGFibGU6cm93OmhlYWRlcicpO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGNvbnN0IGFjY2Vzc29yID0ge1xuICAgICAgX3NtdWlfZGF0YV90YWJsZV9yb3dfYWNjZXNzb3I6ICFoZWFkZXIsXG4gICAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEVsZW1lbnQoKTtcbiAgICAgIH0sXG4gICAgICBnZXQgY2hlY2tib3goKSB7XG4gICAgICAgIHJldHVybiBjaGVja2JveDtcbiAgICAgIH0sXG4gICAgICBnZXQgcm93SWQoKSB7XG4gICAgICAgIHJldHVybiByb3dJZDtcbiAgICAgIH0sXG4gICAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBjaGVja2JveCAmJiBjaGVja2JveC5jaGVja2VkO1xuICAgICAgfSxcbiAgICAgIGFkZENsYXNzLFxuICAgICAgcmVtb3ZlQ2xhc3MsXG4gICAgICBnZXRBdHRyLFxuICAgICAgYWRkQXR0cixcbiAgICB9O1xuXG4gICAgZGlzcGF0Y2goZ2V0RWxlbWVudCgpLCAnU01VSTpkYXRhLXRhYmxlOnJvdzptb3VudCcsIGFjY2Vzc29yKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdTTVVJOmRhdGEtdGFibGU6cm93OnVubW91bnQnKTtcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICBpZiAoIWludGVybmFsQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICBpbnRlcm5hbENsYXNzZXNbY2xhc3NOYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgaWYgKCEoY2xhc3NOYW1lIGluIGludGVybmFsQ2xhc3NlcykgfHwgaW50ZXJuYWxDbGFzc2VzW2NsYXNzTmFtZV0pIHtcbiAgICAgIGludGVybmFsQ2xhc3Nlc1tjbGFzc05hbWVdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXR0cihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gaW50ZXJuYWxBdHRyc1xuICAgICAgPyBpbnRlcm5hbEF0dHJzW25hbWVdXG4gICAgICA6IGdldEVsZW1lbnQoKS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRBdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGludGVybmFsQXR0cnNbbmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICBpbnRlcm5hbEF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5SGVhZGVyQ2xpY2soZXZlbnQpIHtcbiAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdTTVVJOmRhdGEtdGFibGU6aGVhZGVyOmNsaWNrJywgZXZlbnQpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwieyNpZiBoZWFkZXJ9XG4gIDx0aFxuICAgIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgICB1c2U6dXNlQWN0aW9ucz17dXNlfVxuICAgIHVzZTpmb3J3YXJkRXZlbnRzXG4gICAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICAgIFtjbGFzc05hbWVdOiB0cnVlLFxuICAgICAgJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbCc6IHRydWUsXG4gICAgICAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljJzogbnVtZXJpYyxcbiAgICAgICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94JzogY2hlY2tib3gsXG4gICAgICAnbWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS13aXRoLXNvcnQnOiBzb3J0YWJsZSxcbiAgICAgICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZCc6IHNvcnRhYmxlICYmICRzb3J0ID09PSBjb2x1bW5JZCxcbiAgICAgIC4uLmludGVybmFsQ2xhc3NlcyxcbiAgICB9KX1cbiAgICBvbjpjaGFuZ2U9eyhldmVudCkgPT4gY2hlY2tib3ggJiYgbm90aWZ5SGVhZGVyQ2hhbmdlKGV2ZW50KX1cbiAgICByb2xlPVwiY29sdW1uaGVhZGVyXCJcbiAgICBzY29wZT1cImNvbFwiXG4gICAgZGF0YS1jb2x1bW4taWQ9e2NvbHVtbklkfVxuICAgIGFyaWEtc29ydD17c29ydGFibGUgPyAoJHNvcnQgPT09IGNvbHVtbklkID8gJHNvcnREaXJlY3Rpb24gOiAnbm9uZScpIDogbnVsbH1cbiAgICB7Li4uaW50ZXJuYWxBdHRyc31cbiAgICB7Li4uJCRyZXN0UHJvcHN9XG4gICAgPnsjaWYgc29ydGFibGV9XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLXdyYXBwZXJcIj5cbiAgICAgICAgPHNsb3QgLz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRhdGEtdGFibGVfX3NvcnQtc3RhdHVzLWxhYmVsXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgIGlkPVwie2NvbHVtbklkfS1zdGF0dXMtbGFiZWxcIlxuICAgICAgICA+XG4gICAgICAgICAgeyRzb3J0ID09PSBjb2x1bW5JZFxuICAgICAgICAgICAgPyAkc29ydERpcmVjdGlvbiA9PT0gJ2FzY2VuZGluZydcbiAgICAgICAgICAgICAgPyBzb3J0QXNjZW5kaW5nQXJpYUxhYmVsXG4gICAgICAgICAgICAgIDogc29ydERlc2NlbmRpbmdBcmlhTGFiZWxcbiAgICAgICAgICAgIDogJyd9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgezplbHNlfTxzbG90IC8+ey9pZn08L3RoXG4gID5cbns6ZWxzZX1cbiAgPHRkXG4gICAgYmluZDp0aGlzPXtlbGVtZW50fVxuICAgIHVzZTp1c2VBY3Rpb25zPXt1c2V9XG4gICAgdXNlOmZvcndhcmRFdmVudHNcbiAgICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgICAgW2NsYXNzTmFtZV06IHRydWUsXG4gICAgICAnbWRjLWRhdGEtdGFibGVfX2NlbGwnOiB0cnVlLFxuICAgICAgJ21kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmljJzogbnVtZXJpYyxcbiAgICAgICdtZGMtZGF0YS10YWJsZV9fY2VsbC0tY2hlY2tib3gnOiBjaGVja2JveCxcbiAgICAgIC4uLmludGVybmFsQ2xhc3NlcyxcbiAgICB9KX1cbiAgICBvbjpjaGFuZ2U9eyhldmVudCkgPT4gY2hlY2tib3ggJiYgbm90aWZ5Qm9keUNoYW5nZShldmVudCl9XG4gICAgey4uLmludGVybmFsQXR0cnN9XG4gICAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvdGRcbiAgPlxuey9pZn1cblxuPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGxldCBjb3VudGVyID0gMDtcbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50LCBnZXRDb250ZXh0LCBzZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHtcbiAgICBmb3J3YXJkRXZlbnRzQnVpbGRlcixcbiAgICBjbGFzc01hcCxcbiAgICB1c2VBY3Rpb25zLFxuICAgIGRpc3BhdGNoLFxuICB9IGZyb20gJ0BzbXVpL2NvbW1vbi9pbnRlcm5hbC5qcyc7XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBsZXQgaGVhZGVyID0gZ2V0Q29udGV4dCgnU01VSTpkYXRhLXRhYmxlOnJvdzpoZWFkZXInKTtcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gIGV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xuICBleHBvcnQgbGV0IG51bWVyaWMgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBjaGVja2JveCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGNvbHVtbklkID0gaGVhZGVyID8gJ1NNVUktZGF0YS10YWJsZS1jb2x1bW4tJyArIGNvdW50ZXIrKyA6IG51bGw7XG4gIGV4cG9ydCBsZXQgc29ydGFibGUgPSBnZXRDb250ZXh0KCdTTVVJOmRhdGEtdGFibGU6c29ydGFibGUnKTtcblxuICBsZXQgZWxlbWVudDtcbiAgbGV0IGludGVybmFsQ2xhc3NlcyA9IHt9O1xuICBsZXQgaW50ZXJuYWxBdHRycyA9IHt9O1xuICBsZXQgc29ydCA9IGdldENvbnRleHQoJ1NNVUk6ZGF0YS10YWJsZTpzb3J0Jyk7XG4gIGxldCBzb3J0RGlyZWN0aW9uID0gZ2V0Q29udGV4dCgnU01VSTpkYXRhLXRhYmxlOnNvcnREaXJlY3Rpb24nKTtcbiAgbGV0IHNvcnRBc2NlbmRpbmdBcmlhTGFiZWwgPSBnZXRDb250ZXh0KFxuICAgICdTTVVJOmRhdGEtdGFibGU6c29ydEFzY2VuZGluZ0FyaWFMYWJlbCdcbiAgKTtcbiAgbGV0IHNvcnREZXNjZW5kaW5nQXJpYUxhYmVsID0gZ2V0Q29udGV4dChcbiAgICAnU01VSTpkYXRhLXRhYmxlOnNvcnREZXNjZW5kaW5nQXJpYUxhYmVsJ1xuICApO1xuXG4gIGlmIChzb3J0YWJsZSkge1xuICAgIHNldENvbnRleHQoJ1NNVUk6bGFiZWw6Y29udGV4dCcsICdkYXRhLXRhYmxlOnNvcnRhYmxlLWhlYWRlci1jZWxsJyk7XG4gICAgc2V0Q29udGV4dCgnU01VSTppY29uLWJ1dHRvbjpjb250ZXh0JywgJ2RhdGEtdGFibGU6c29ydGFibGUtaGVhZGVyLWNlbGwnKTtcbiAgICBzZXRDb250ZXh0KCdTTVVJOmljb24tYnV0dG9uOmFyaWEtZGVzY3JpYmVkYnknLCBjb2x1bW5JZCArICctc3RhdHVzLWxhYmVsJyk7XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHtcbiAgICAgIF9zbXVpX2RhdGFfdGFibGVfaGVhZGVyX2NlbGxfYWNjZXNzb3I6IGhlYWRlcixcbiAgICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gZ2V0RWxlbWVudCgpO1xuICAgICAgfSxcbiAgICAgIGdldCBjb2x1bW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbklkO1xuICAgICAgfSxcbiAgICAgIGFkZENsYXNzLFxuICAgICAgcmVtb3ZlQ2xhc3MsXG4gICAgICBnZXRBdHRyLFxuICAgICAgYWRkQXR0cixcbiAgICB9O1xuXG4gICAgZGlzcGF0Y2goZ2V0RWxlbWVudCgpLCAnU01VSTpkYXRhLXRhYmxlOmNlbGw6bW91bnQnLCBhY2Nlc3Nvcik7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2goZ2V0RWxlbWVudCgpLCAnU01VSTpkYXRhLXRhYmxlOmNlbGw6dW5tb3VudCcpO1xuICAgIH07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzTmFtZSkge1xuICAgIGlmICghaW50ZXJuYWxDbGFzc2VzW2NsYXNzTmFtZV0pIHtcbiAgICAgIGludGVybmFsQ2xhc3Nlc1tjbGFzc05hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHtcbiAgICBpZiAoIShjbGFzc05hbWUgaW4gaW50ZXJuYWxDbGFzc2VzKSB8fCBpbnRlcm5hbENsYXNzZXNbY2xhc3NOYW1lXSkge1xuICAgICAgaW50ZXJuYWxDbGFzc2VzW2NsYXNzTmFtZV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdHRyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSBpbiBpbnRlcm5hbEF0dHJzXG4gICAgICA/IGludGVybmFsQXR0cnNbbmFtZV1cbiAgICAgIDogZ2V0RWxlbWVudCgpLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoaW50ZXJuYWxBdHRyc1tuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgIGludGVybmFsQXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlIZWFkZXJDaGFuZ2UoZXZlbnQpIHtcbiAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdTTVVJOmRhdGEtdGFibGU6aGVhZGVyOmNoZWNrYm94OmNoYW5nZScsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUJvZHlDaGFuZ2UoZXZlbnQpIHtcbiAgICBkaXNwYXRjaChnZXRFbGVtZW50KCksICdTTVVJOmRhdGEtdGFibGU6Ym9keTpjaGVja2JveDpjaGFuZ2UnLCBldmVudCk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxyXG5cdGltcG9ydCBEYXRhVGFibGUsIHtcclxuXHRcdEhlYWQsXHJcblx0XHRCb2R5LFxyXG5cdFx0Um93LFxyXG5cdFx0Q2VsbCxcclxuXHRcdExhYmVsXHJcblx0fSBmcm9tICdAc211aS9kYXRhLXRhYmxlJztcclxuICBcdGltcG9ydCBJY29uQnV0dG9uIGZyb20gJ0BzbXVpL2ljb24tYnV0dG9uJztcclxuICAgIGltcG9ydCBCdXR0b24sIHsgTGFiZWwgYXMgTGFiZWxCdXR0b24sIEljb24gfSBmcm9tICdAc211aS9idXR0b24nO1xyXG4gICAgaW1wb3J0IHVzZXJzIGZyb20gJy4uLy4uL3N0b3JlL3VzZXJzLXN0b3JlJztcclxuXHJcbiAgICBleHBvcnQgbGV0IGZldGNoZWRVc2VycztcclxuICAgICAgXHJcblx0bGV0IHNvcnQgPSAnaWQnO1xyXG5cdGxldCBzb3J0RGlyZWN0aW9uID0gJ2FzY2VuZGluZyc7XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU29ydCgpIHtcclxuICAgICAgICBmZXRjaGVkVXNlcnMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBbYVZhbCwgYlZhbF0gPSBbYVtzb3J0XSwgYltzb3J0XV1bXHJcbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uID09PSAnYXNjZW5kaW5nJyA/ICdzbGljZScgOiAncmV2ZXJzZSdcclxuICAgICAgICAgICAgXSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhVmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFWYWwubG9jYWxlQ29tcGFyZShiVmFsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFWYWwgLSBiVmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB1c2Vycy5zZXRVc2VycyhmZXRjaGVkVXNlcnMpO1xyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuXHJcbjxEYXRhVGFibGVcclxuICAgIHNvcnRhYmxlXHJcbiAgICBiaW5kOnNvcnRcclxuICAgIGJpbmQ6c29ydERpcmVjdGlvblxyXG4gICAgb246TURDRGF0YVRhYmxlOnNvcnRlZD17aGFuZGxlU29ydH1cclxuICAgIHRhYmxlJGFyaWEtbGFiZWw9XCJVc2VyIGxpc3RcIlxyXG4gICAgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIj5cclxuICAgIDxIZWFkPlxyXG4gICAgICAgIDxSb3c+XHJcbiAgICAgICAgICAgIDxDZWxsIG51bWVyaWMgY29sdW1uSWQ9XCJpZFwiPlxyXG4gICAgICAgICAgICAgICAgPEljb25CdXR0b24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmFycm93X3Vwd2FyZDwvSWNvbkJ1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxMYWJlbD5JRDwvTGFiZWw+XHJcbiAgICAgICAgICAgIDwvQ2VsbD5cclxuICAgICAgICAgICAgPENlbGwgY29sdW1uSWQ9XCJuYW1lXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIj5cclxuICAgICAgICAgICAgICAgIDxMYWJlbD5OYW1lPC9MYWJlbD5cclxuICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5hcnJvd191cHdhcmQ8L0ljb25CdXR0b24+XHJcbiAgICAgICAgICAgIDwvQ2VsbD5cclxuICAgICAgICAgICAgPENlbGwgY29sdW1uSWQ9XCJ1c2VybmFtZVwiPlxyXG4gICAgICAgICAgICAgICAgPExhYmVsPlVzZXJuYW1lPC9MYWJlbD5cclxuICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5hcnJvd191cHdhcmQ8L0ljb25CdXR0b24+XHJcbiAgICAgICAgICAgIDwvQ2VsbD5cclxuICAgICAgICAgICAgPENlbGwgY29sdW1uSWQ9XCJlbWFpbFwiIGw+XHJcbiAgICAgICAgICAgICAgICA8TGFiZWw+RW1haWw8L0xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPEljb25CdXR0b24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmFycm93X3Vwd2FyZDwvSWNvbkJ1dHRvbj5cclxuICAgICAgICAgICAgPC9DZWxsPlxyXG4gICAgICAgICAgICA8Q2VsbCBzb3J0YWJsZT17ZmFsc2V9PldlYnNpdGU8L0NlbGw+XHJcbiAgICAgICAgICAgIDxDZWxsIHNvcnRhYmxlPXtmYWxzZX0+QWN0aW9uczwvQ2VsbD5cclxuICAgICAgICA8L1Jvdz5cclxuICAgIDwvSGVhZD5cclxuICAgIDxCb2R5PlxyXG4gICAgICAgIHsjZWFjaCBmZXRjaGVkVXNlcnMgYXMgaXRlbSAoaXRlbS5pZCl9XHJcbiAgICAgICAgICAgIDxSb3c+XHJcbiAgICAgICAgICAgICAgICA8Q2VsbCBudW1lcmljPntpdGVtLmlkfTwvQ2VsbD5cclxuICAgICAgICAgICAgICAgIDxDZWxsPntpdGVtLm5hbWV9PC9DZWxsPlxyXG4gICAgICAgICAgICAgICAgPENlbGw+e2l0ZW0udXNlcm5hbWV9PC9DZWxsPlxyXG4gICAgICAgICAgICAgICAgPENlbGw+e2l0ZW0uZW1haWx9PC9DZWxsPlxyXG4gICAgICAgICAgICAgICAgPENlbGw+e2l0ZW0ud2Vic2l0ZX08L0NlbGw+XHJcbiAgICAgICAgICAgICAgICA8Q2VsbD5cclxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIGhyZWY9XCIvdXNlci9mb3JtL3tpdGVtLmlkfVwiIHZhcmlhbnQ9XCJyYWlzZWRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0ljb24+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TGFiZWxCdXR0b24+RWRpdDwvTGFiZWxCdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gb246Y2xpY2s9eygpID0+IGNvbnNvbGUubG9nKCdjbGlja2VkIScpfSB2YXJpYW50PVwib3V0bGluZWRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlX2NpcmNsZV9vdXRsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvSWNvbj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYWJlbEJ1dHRvbj5EZWxldGU8L0xhYmVsQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9DZWxsPlxyXG4gICAgICAgICAgICA8L1Jvdz5cclxuICAgICAgICB7L2VhY2h9XHJcbiAgICA8L0JvZHk+XHJcbjwvRGF0YVRhYmxlPlxyXG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBvbk1vdW50LCBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgdXNlcnMgZnJvbSAnLi4vLi4vc3RvcmUvdXNlcnMtc3RvcmUnO1xuXHRpbXBvcnQgQnV0dG9uLCB7IExhYmVsIH0gZnJvbSAnQHNtdWkvYnV0dG9uJztcblx0aW1wb3J0IExvYWRpbmdTcGlubmVyIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvVUkvY29tcG9uZW50L0xvYWRpbmdTcGlubmVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBVc2VyVGFibGUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Vc2VyL1VzZXJUYWJsZS5zdmVsdGUnO1xuXHRcblx0bGV0IGZldGNoZWRVc2VycztcblxuXHRsZXQgdW5zdWJzY3JpYmU7XG5cdGxldCBpc0xvYWRpbmcgPSB0cnVlO1xuXG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdHVuc3Vic2NyaWJlID0gdXNlcnMuc3Vic2NyaWJlKChpdGVtcykgPT4ge1xuXHRcdFx0ZmV0Y2hlZFVzZXJzID0gaXRlbXM7XG5cdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblx0XHR9KVxuXHR9KTtcblxuXHRvbkRlc3Ryb3koKCkgPT4ge1xuXHRcdGlmICh1bnN1YnNjcmliZSkge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH0pO1xuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPkRhc2hib2FyZDwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48ZGl2IGNsYXNzPVwiZmxleC1lbmQtYnRuXCI+XG5cdDxCdXR0b24gaHJlZj1cIi91c2VyL2Zvcm1cIiB2YXJpYW50PVwicmFpc2VkXCI+XG5cdFx0PExhYmVsPkFkZCBOZXcgVXNlcjwvTGFiZWw+XG5cdDwvQnV0dG9uPlxuPC9kaXY+XG5cbnsjaWYgaXNMb2FkaW5nfVxuXHQ8TG9hZGluZ1NwaW5uZXIgLz5cbns6ZWxzZX1cblx0PFVzZXJUYWJsZSB7ZmV0Y2hlZFVzZXJzfSAvPlxuey9pZn1cbiJdLCJuYW1lcyI6WyJjb3VudGVyIiwidXNlcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O2lDQUFrRSxHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkVBQXRDLEdBQUc7Ozs7Ozs7Ozs7Ozs7O3dHQUF3QixHQUFXO29JQUF0QyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FRN0IsR0FBRztPQUVSLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQyxxQkFBcUI7S0FFNUQsT0FBTyxHQUFHLElBQUk7O1VBRUYsVUFBVTtTQUNqQixPQUFPOzs7OztHQWZKLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0NBK0MsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZFQUF0QyxHQUFHOzs7Ozs7Ozs7Ozs7OztrSEFBd0IsR0FBVztvSUFBdEMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BUS9CLEdBQUc7T0FFUixhQUFhLEdBQUcsb0JBQW9CLENBQUMscUJBQXFCO0tBRTVELE9BQU8sR0FBRyxJQUFJOztVQUVGLFVBQVU7U0FDakIsT0FBTzs7Ozs7R0FmRixPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkNHZixHQUFhLGdCQUFLLEdBQUc7OztVQUNwQixRQUFRO21CQUNaLEdBQVMsTUFBRyxJQUFJO0lBQ2pCLGtCQUFrQixjQUFFLEdBQU8sUUFBSyxRQUFRO0lBQ3hDLGVBQWUsY0FBRSxHQUFPLFFBQUssS0FBSztJQUNsQyx1QkFBdUIsY0FBRSxHQUFPLFFBQUssYUFBYTtJQUNsRCwyQkFB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NDU2hDLEtBQUs7Ozs7Ozs7OztjQUNMLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQU1GLEdBQUks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
